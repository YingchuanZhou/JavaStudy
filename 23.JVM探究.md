# JVM

## JVM探究

- 请你谈谈对JVM的理解? java8虚拟机和之前的变化更新
- 什么是OOM(内存溢出)? 什么是栈溢出(stackOverFlowError)? 怎么分析?
- JVM常用的调优参数有哪些?
- 内存快照如何抓取? 怎么分析Domp文件 ? 知道吗?
- 谈谈JVM中,类加载器你的认识?

## **1.jvm的位置**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115505543.png)

## **2.jvm的体系结构**	

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115523922.png)

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/2020092611555012.png)

## **3.类加载器**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115601139.png)

## **4.双亲委派机制**

1. 虚拟机自带的加载器

2. 启动类 (根) 加载器

3. 扩展类加载器

4. 应用程序加载器

   app—>扩展类(ext) ----> (启动类)根加载器(rt) —>

   - 1.类加载器收到类加载的请求
   - 2.将这个请求向上委托给父类加载器去完成, 一直向上委托, 直到启动类加载器(根加载器rt)
   - 3.启动类加载器检查是否能够加载当前这个类, 能够加载就结束了, 使用当前加载器,否则抛出异常,通知子类加载器进行加载.
   - 4.重复步骤3.

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115616115.png)

## **5.沙箱安全机制**

Java安全模型的核心就是Java沙箱(sandbox) ,
  什么是沙箱?沙箱是一个限制程序运行的环境。沙箱机制就是**将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问**，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。
  沙箱主要限制系统资源访问，那系统资源包括什么? CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。
  所有的Java程序运行都可以指定沙箱，可以定制安全策略。
  在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码,可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱Sandbox)机制。如下图所示JDK1.0安全模型

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200828103007804.png)

 但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200828103044782.png)

 在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200828103059461.png)

 当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域,系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain),对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示最新的安全模型(jdk 1.6)
![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200714084152611.png)

图 JDK1.6安全模型

**组成沙箱的基本组件**

●字节码校验器(bytecode verifier) :确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。
●类裝载器(class loader) :其中类装载器在3个方面对Java沙箱起作用
  它防止恶意代码去干涉善意的代码;
  它守护了被信任的类库边界;
  它将代码归入保护域,确定了代码可以进行哪些操作。
 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成， 每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。
 类装载器采用的机制是双亲委派模式。
 1.从最内层JVM自带类加载器开始加载,外层恶意同名类得不到加载从而无法使用;
 2.由于严格通过包来区分了访问域,外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。
●存取控制器(access controller) :存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定,可以由用户指定。
●安全管理器(security manager) : 是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。
●安全软件包(security package) : java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:
  安全提供者
  消息摘要
  数字签名
  加密
  鉴别

## **6.Native**

Native 关键字 调用 本地方法栈----> JNI (java Native Interface本地方法接口) 调用外部语言程序

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115627112.png)

## **7.pc寄存器**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/2020092611563737.png)

## **8.方法区**

方法区是被所有线程共享,所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域,此区域属于共享区间;
 **静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200715083015673.png)

## 9、栈

栈: 先进后出,后进先出

队列: 先进先出 (FIFO)

喝多了吐就是栈,吃多了拉就是队列

栈:栈内存,主管程序的运行,生命周期和线程同步;

线程结束,栈内存也就释放了,对于栈来说,不存在垃圾回收问题

一旦线程结束,栈就Over

栈:8大基本类型+ 对象引用+实例的方法

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115653964.png)

- 栈 + 堆 +方法区:交互关系

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200715083341700.png)

- 在内存中画出一个对象的实例化过程

扩展：

**对象实例化过程**,总之一句话,静态代码块内容先执行(**父先子后**),接着执行父类费静泰代码块和构造方法,然后执行子类非静态代码块和构造方法.

栈溢出(StackOverflowError),a方法调用b方法,b方法调用a方法,死循环无限执行.

Robot(),机器人类可以操作电脑.

## **10.三种JVM**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115715187.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200926115723908.png#pic_center)

## **11.堆**

Heap,一个JVM只有一个堆内存,堆内存的大小是可以调节的.

类加载器读取了类文件后,一般会把什么东西放到堆中? 类, 方法 , 常量 , 变量 , ~,保存我们所有引用类型的真实对象;

堆内存中还要细分为三个区域:

- 新生区 (伊甸园区) Young/New
- 养老区 old
- 永久区 Perm jdk8之后叫做 “元空间”

JDK1.7

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115738454.png)

JDK1.8之后

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115747987.png)

GC垃圾回收, 主要在伊甸园区和养老区~

假设内存满了,OOM内存不够了! java.lang.OutOfMemoryError: java heap space

### **新生区** （满了 轻GC）

- 类 ： 诞生和成长的地方 ， 甚至死亡；
- 伊甸园， 所有的对象都是在伊甸园区new出来的
- 幸存区（0，1）
- 经研究99%的对象都是临时对象

1. **老年区** （满了 重GC）

2. **永久区**

   这个区域常驻内存的. 用来存放jdk自身携带的Class对象.Interface元数据,存储的是java运行时的一些环境或类信息,这个区域不存在垃圾回收!关闭vm虚拟就会释放这个区域的内存~.

   - jdk1.6之前 :永久代,常量池是在方法区;
   - jdk1.7 :永久代,但是慢慢退化了, `去永久代`,常量池在堆中;
   - jdk1.8之后:无永久代, 常量池在元空间;

- **堆**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115803745.png)

1. 元空间：逻辑上存在,物理上不存在，新生区和老年区内存相加已经等于堆内存了

### **堆内存调优**

默认情况下: 分配的总内存 是电脑内存的1/4,而初始化的内存: 1/64

OOM:堆内存溢出

1. 尝试扩大堆内存看结果
   - -Xms1024m -Xmx1024m -xx:+PrintGCDetails
2. 分析内存,看一下哪个地方出现了问题 (专业工具)

在一个项目中,突然出现了OOM故障,那么该如何排除~研究为什么出错

- 能够看到代码第几行出错:内存快照分析工具,MAT,Jprofiler
- Dubug,一行行分析代码

### **MAT,Jprogiler作用:**

- 分析Dump内存文件,快速定位内存泄漏
- 获得堆中的数据
- 获得大的对象

### **Jprofiler安装过程**

1. idea中安装插件Plugins中搜索Jprofiler
2. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115819221.png)
3. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115828741.png)
4. 重启idea
5. 安装客户端jprofiler
6. 上网找安装包,安装很简单
7. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115841375.png)
8. 注册
9. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115851255.png)
10. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115900860.png)
11. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115910468.png)

### **jprofiler使用**

-Xms 设置初始化内存分配大小 1/64

-Xmx 设置最大分配内存,默认1/4

-XX:+HeapDumpOnOutOfMemoryError oomDump

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115922628.png)

- 看这个
- ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115931714.png)
- ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115948565.png)



## **12.GC**:**垃圾回收**

GC:作用区域 堆+方法区

JVM在进行GC时，并不是对这三个区域统一回收。大部分时候，回收都是新生代~

- 新生代
- 幸存区（form ， to）
- 老年区

GC两种：轻GC（普通GC），重GC（全局GC）

**GC题目**

- JVM的内存模型和分区~详细到每个区放什么?
- 堆里面的分区有哪些? Eden,form,to,老年区,说说他们的特点?
- GC的算法有哪些? 标记清除法 , 标记压缩 , 复制算法, 引用计数器, 怎么用的?
- 轻GC和重GC分别在什么时候发生?

## **13.常用算法**

1. ### **引用计数法**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120004515.png)

1. ### **复制算法**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120015325.png)

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/2020092612002912.png)

- 好处:没有内存的碎片
- 坏处:浪费了内存空间:多了一半空间永远是空 to.假设对象100%存活(极端情况)
- **复制算法最佳使用场景**:对象存活度较低的时候:新生区;

1. ### **标记清除算法**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120039882.png)

- 优点:不需要额外的空间
- 缺点:两次扫描,严重浪费时间,会产生内存碎片

1. ### **标记压缩(优化标记清除)**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120051707.png)

- 三部曲:标记,清除.压缩

### 如何选择四种算法:

**内存效率**:复制算法 > 标记清除算法 > 标记压缩算法(时间复杂度)

**内存整齐度**:复制算法 = 标记压缩算法 > 标记清除算法

**内存利用率**:标记压缩算法 = 标记清除算法 > 复制算法

难道没有一个最优的算法吗?

答案:**没有**,没有最好的算法,只有最合适的算法---->GC:分带收集算法

**年轻代:**

- 存活率低
- 复制算法

**老年代：**

- 区域大：存活率
- 标记清除（内存碎片不是太多）+标记压缩混合实现

## **JMM**

1.什么是JMM？

JMM ：（java Memory Model 缩写）java内存模型

2.他是干什么的？

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020092612010865.png#pic_center)

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120117490.png)

解决共享对象可见性的问题：volilate

3.他该如何学习

JMM ：抽象的概念，理论

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200926120127435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjQ5MjIz,size_16,color_FFFFFF,t_70#pic_center)

=======
# JVM

## JVM探究

- 请你谈谈对JVM的理解? java8虚拟机和之前的变化更新
- 什么是OOM(内存溢出)? 什么是栈溢出(stackOverFlowError)? 怎么分析?
- JVM常用的调优参数有哪些?
- 内存快照如何抓取? 怎么分析Domp文件 ? 知道吗?
- 谈谈JVM中,类加载器你的认识?

## **1.jvm的位置**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115505543.png)

## **2.jvm的体系结构**	

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115523922.png)

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/2020092611555012.png)

## **3.类加载器**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115601139.png)

## **4.双亲委派机制**

1. 虚拟机自带的加载器

2. 启动类 (根) 加载器

3. 扩展类加载器

4. 应用程序加载器

   app—>扩展类(ext) ----> (启动类)根加载器(rt) —>

   - 1.类加载器收到类加载的请求
   - 2.将这个请求向上委托给父类加载器去完成, 一直向上委托, 直到启动类加载器(根加载器rt)
   - 3.启动类加载器检查是否能够加载当前这个类, 能够加载就结束了, 使用当前加载器,否则抛出异常,通知子类加载器进行加载.
   - 4.重复步骤3.

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115616115.png)

## **5.沙箱安全机制**

Java安全模型的核心就是Java沙箱(sandbox) ,
  什么是沙箱?沙箱是一个限制程序运行的环境。沙箱机制就是**将Java代码限定在虚拟机(JVM)特定的运行范围中，并且严格限制代码对本地系统资源访问**，通过这样的措施来保证对代码的有效隔离，防止对本地系统造成破坏。
  沙箱主要限制系统资源访问，那系统资源包括什么? CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。
  所有的Java程序运行都可以指定沙箱，可以定制安全策略。
  在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码,可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于沙箱Sandbox)机制。如下图所示JDK1.0安全模型

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200828103007804.png)

 但如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。因此在后续的Java1.1版本中，针对安全机制做了改进，增加了安全策略，允许用户指定代码对本地资源的访问权限。如下图所示JDK1.1安全模型

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200828103044782.png)

 在Java1.2版本中，再次改进了安全机制，增加了代码签名。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制。如下图所示

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200828103059461.png)

 当前最新的安全机制实现，则引入了域(Domain)的概念。虚拟机会把所有代码加载到不同的系统域和应用域,系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域(Protected Domain),对应不一样的权限(Permission)。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示最新的安全模型(jdk 1.6)
![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200714084152611.png)

图 JDK1.6安全模型

**组成沙箱的基本组件**

●字节码校验器(bytecode verifier) :确保Java类文件遵循Java语言规范。这样可以帮助Java程序实现内存保护。但并不是所有的类文件都会经过字节码校验，比如核心类。
●类裝载器(class loader) :其中类装载器在3个方面对Java沙箱起作用
  它防止恶意代码去干涉善意的代码;
  它守护了被信任的类库边界;
  它将代码归入保护域,确定了代码可以进行哪些操作。
 虚拟机为不同的类加载器载入的类提供不同的命名空间，命名空间由一系列唯一的名称组成， 每一个被装载的类将有一个名字，这个命名空间是由Java虚拟机为每一个类装载器维护的，它们互相之间甚至不可见。
 类装载器采用的机制是双亲委派模式。
 1.从最内层JVM自带类加载器开始加载,外层恶意同名类得不到加载从而无法使用;
 2.由于严格通过包来区分了访问域,外层恶意的类通过内置代码也无法获得权限访问到内层类，破坏代码就自然无法生效。
●存取控制器(access controller) :存取控制器可以控制核心API对操作系统的存取权限，而这个控制的策略设定,可以由用户指定。
●安全管理器(security manager) : 是核心API和操作系统之间的主要接口。实现权限控制，比存取控制器优先级高。
●安全软件包(security package) : java.security下的类和扩展包下的类，允许用户为自己的应用增加新的安全特性，包括:
  安全提供者
  消息摘要
  数字签名
  加密
  鉴别

## **6.Native**

Native 关键字 调用 本地方法栈----> JNI (java Native Interface本地方法接口) 调用外部语言程序

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115627112.png)

## **7.pc寄存器**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/2020092611563737.png)

## **8.方法区**

方法区是被所有线程共享,所有字段和方法字节码，以及一些特殊方法，如构造函数,接口代码也在此定义,简单说，所有定义的方法的信息都保存在该区域,此区域属于共享区间;
 **静态变量、常量、类信息(构造方法、接口定义)、运行时的常量池存在方法区中，但是实例变量存在堆内存中，和方法区无关**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200715083015673.png)

## 9、栈

栈: 先进后出,后进先出

队列: 先进先出 (FIFO)

喝多了吐就是栈,吃多了拉就是队列

栈:栈内存,主管程序的运行,生命周期和线程同步;

线程结束,栈内存也就释放了,对于栈来说,不存在垃圾回收问题

一旦线程结束,栈就Over

栈:8大基本类型+ 对象引用+实例的方法

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115653964.png)

- 栈 + 堆 +方法区:交互关系

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200715083341700.png)

- 在内存中画出一个对象的实例化过程

扩展：

**对象实例化过程**,总之一句话,静态代码块内容先执行(**父先子后**),接着执行父类费静泰代码块和构造方法,然后执行子类非静态代码块和构造方法.

栈溢出(StackOverflowError),a方法调用b方法,b方法调用a方法,死循环无限执行.

Robot(),机器人类可以操作电脑.

## **10.三种JVM**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115715187.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200926115723908.png#pic_center)

## **11.堆**

Heap,一个JVM只有一个堆内存,堆内存的大小是可以调节的.

类加载器读取了类文件后,一般会把什么东西放到堆中? 类, 方法 , 常量 , 变量 , ~,保存我们所有引用类型的真实对象;

堆内存中还要细分为三个区域:

- 新生区 (伊甸园区) Young/New
- 养老区 old
- 永久区 Perm jdk8之后叫做 “元空间”

JDK1.7

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115738454.png)

JDK1.8之后

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115747987.png)

GC垃圾回收, 主要在伊甸园区和养老区~

假设内存满了,OOM内存不够了! java.lang.OutOfMemoryError: java heap space

### **新生区** （满了 轻GC）

- 类 ： 诞生和成长的地方 ， 甚至死亡；
- 伊甸园， 所有的对象都是在伊甸园区new出来的
- 幸存区（0，1）
- 经研究99%的对象都是临时对象

1. **老年区** （满了 重GC）

2. **永久区**

   这个区域常驻内存的. 用来存放jdk自身携带的Class对象.Interface元数据,存储的是java运行时的一些环境或类信息,这个区域不存在垃圾回收!关闭vm虚拟就会释放这个区域的内存~.

   - jdk1.6之前 :永久代,常量池是在方法区;
   - jdk1.7 :永久代,但是慢慢退化了, `去永久代`,常量池在堆中;
   - jdk1.8之后:无永久代, 常量池在元空间;

- **堆**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115803745.png)

1. 元空间：逻辑上存在,物理上不存在，新生区和老年区内存相加已经等于堆内存了

### **堆内存调优**

默认情况下: 分配的总内存 是电脑内存的1/4,而初始化的内存: 1/64

OOM:堆内存溢出

1. 尝试扩大堆内存看结果
   - -Xms1024m -Xmx1024m -xx:+PrintGCDetails
2. 分析内存,看一下哪个地方出现了问题 (专业工具)

在一个项目中,突然出现了OOM故障,那么该如何排除~研究为什么出错

- 能够看到代码第几行出错:内存快照分析工具,MAT,Jprofiler
- Dubug,一行行分析代码

### **MAT,Jprogiler作用:**

- 分析Dump内存文件,快速定位内存泄漏
- 获得堆中的数据
- 获得大的对象

### **Jprofiler安装过程**

1. idea中安装插件Plugins中搜索Jprofiler
2. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115819221.png)
3. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115828741.png)
4. 重启idea
5. 安装客户端jprofiler
6. 上网找安装包,安装很简单
7. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115841375.png)
8. 注册
9. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115851255.png)
10. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115900860.png)
11. ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115910468.png)

### **jprofiler使用**

-Xms 设置初始化内存分配大小 1/64

-Xmx 设置最大分配内存,默认1/4

-XX:+HeapDumpOnOutOfMemoryError oomDump

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115922628.png)

- 看这个
- ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115931714.png)
- ![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926115948565.png)



## **12.GC**:**垃圾回收**

GC:作用区域 堆+方法区

JVM在进行GC时，并不是对这三个区域统一回收。大部分时候，回收都是新生代~

- 新生代
- 幸存区（form ， to）
- 老年区

GC两种：轻GC（普通GC），重GC（全局GC）

**GC题目**

- JVM的内存模型和分区~详细到每个区放什么?
- 堆里面的分区有哪些? Eden,form,to,老年区,说说他们的特点?
- GC的算法有哪些? 标记清除法 , 标记压缩 , 复制算法, 引用计数器, 怎么用的?
- 轻GC和重GC分别在什么时候发生?

## **13.常用算法**

1. ### **引用计数法**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120004515.png)

1. ### **复制算法**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120015325.png)

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/2020092612002912.png)

- 好处:没有内存的碎片
- 坏处:浪费了内存空间:多了一半空间永远是空 to.假设对象100%存活(极端情况)
- **复制算法最佳使用场景**:对象存活度较低的时候:新生区;

1. ### **标记清除算法**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120039882.png)

- 优点:不需要额外的空间
- 缺点:两次扫描,严重浪费时间,会产生内存碎片

1. ### **标记压缩(优化标记清除)**

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120051707.png)

- 三部曲:标记,清除.压缩

### 如何选择四种算法:

**内存效率**:复制算法 > 标记清除算法 > 标记压缩算法(时间复杂度)

**内存整齐度**:复制算法 = 标记压缩算法 > 标记清除算法

**内存利用率**:标记压缩算法 = 标记清除算法 > 复制算法

难道没有一个最优的算法吗?

答案:**没有**,没有最好的算法,只有最合适的算法---->GC:分带收集算法

**年轻代:**

- 存活率低
- 复制算法

**老年代：**

- 区域大：存活率
- 标记清除（内存碎片不是太多）+标记压缩混合实现

## **JMM**

1.什么是JMM？

JMM ：（java Memory Model 缩写）java内存模型

2.他是干什么的？

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020092612010865.png#pic_center)

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120117490.png)

解决共享对象可见性的问题：volilate

3.他该如何学习

JMM ：抽象的概念，理论

![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120127435.png)



![在这里插入图片描述](23.JVM%E6%8E%A2%E7%A9%B6.assets/20200926120136562.png)