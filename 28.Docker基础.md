# Docker概述

## Docker为什么出现？

一款产品： 开发–上线 两套环境！应用环境，应用配置！

开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？

环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。

发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！

之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。

开发环境Windows，最后发布到Linux！

传统：开发jar，运维来做！

现在：开发打包部署上线，一套流程做完！

安卓流程：java — apk —发布（应用商店）一 张三使用apk一安装即可用！

docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）-----

Docker给以上的问题，提出了解决方案！

![image-20200514192040435](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDE5MjA0MDQzNS5wbmc)

Docker的思想就来自于集装箱！

JRE – 多个应用(端口冲突) – 原来都是交叉的！
隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。

Docker通过隔离机制，可以将服务器利用到极致！

本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！

## Docker历史

2010年，几个的年轻人，就在美国成立了一家公司 `dotcloud`

做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！

> Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。

他们将自己的技术（容器化技术）命名就是 Docker
Docker刚刚延生的时候，没有引起行业的注意！`dotCloud`，就活不下去！

**开源**

2013年，Docker开源！

越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！

2014年4月9日，Docker1.0发布！

docker为什么这么火？十分的轻巧！

在容器技术出来之前，我们都是使用虚拟机技术！

虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！

虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！

| 虚拟机                           | Docker                                |
| -------------------------------- | ------------------------------------- |
| linux centos原生镜像（一个电脑） | 隔离镜像（最核心的环境 +jdk +mysql等) |
| 需要开启多个虚拟机               | 运行镜像就可以了                      |
| 几GB                             | 几MB                                  |

```bash
vm : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟
docker: 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！
```

> 聊聊Docker

Docker基于Go语言开发的！开源项目！

docker官网：https://www.docker.com/

文档：https://docs.docker.com/ Docker的文档是超级详细的！

仓库：https://hub.docker.com/

## Docker能干嘛

> 之前的虚拟机技术！

![image-20200515153852954](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE1Mzg1Mjk1NC5wbmc)

**虚拟机技术缺点**：

1、 资源占用十分多

2、 冗余步骤多

3、 启动很慢！

> 容器化技术

容器化技术不是模拟一个完整的操作系统

![image-20200515094336846](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTA5NDMzNjg0Ni5wbmc)

比较Docker和虚拟机技术的不同：

* 传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件
* 容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了
* 每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响

> DevOps（开发、运维）

**应用更快速的交付和部署**

传统：一对帮助文档，安装程序。

Docker：打包镜像发布测试一键运行。

**更便捷的升级和扩缩容**

使用了 Docker之后，我们部署应用就和搭积木一样
项目打包为一个镜像，扩展服务器A！服务器B

**更简单的系统运维**
在容器化之后，我们的开发，测试环境都是高度一致的

**更高效的计算资源利用**

Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。

# Docker安装

## Docker的基本组成

![20201208171750](28.Docker%E5%9F%BA%E7%A1%80.assets/20201208171750.png)

**镜像（image)：**

docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像==>run==>容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。

**容器(container)：**

Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.
启动，停止，删除，基本命令
目前就可以把这个容器理解为就是一个简易的 Linux系统。

**仓库(repository)：**

仓库就是存放镜像的地方！
仓库分为公有仓库和私有仓库。(很类似git)
Docker Hub是国外的。
阿里云…都有容器服务器(配置镜像加速!)

## 安装Docker

> 环境准备

Linux要求内核3.0以上

> 环境查看

```bash
# 系统内核是3.10以上
[root@izwz94zhiwnwqwtv5ewlnwz ~]# uname -r
3.10.0-514.26.2.el7.x86_64
```

```bash
# 系统版本
[root@izwz94zhiwnwqwtv5ewlnwz ~]# cat /etc/os-release
NAME="CentOS Linux"
VERSION="7 (Core)"
ID="centos"
ID_LIKE="rhel fedora"
VERSION_ID="7"
PRETTY_NAME="CentOS Linux 7 (Core)"
ANSI_COLOR="0;31"
CPE_NAME="cpe:/o:centos:centos:7"
HOME_URL="https://www.centos.org/"
BUG_REPORT_URL="https://bugs.centos.org/"

CENTOS_MANTISBT_PROJECT="CentOS-7"
CENTOS_MANTISBT_PROJECT_VERSION="7"
REDHAT_SUPPORT_PRODUCT="centos"
REDHAT_SUPPORT_PRODUCT_VERSION="7"
```

> 安装

帮助文档：https://docs.docker.com/engine/install/

```bash
#1.卸载旧版本
yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
#2.需要的安装包
yum install -y yum-utils
#3.设置镜像的仓库
yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
#默认是从国外的，不推荐
#推荐使用国内的
yum-config-manager \
    --add-repo \
    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
#更新yum软件包索引
yum makecache fast
#4.安装docker相关的 docker-ce 社区版 而ee是企业版
yum install docker-ce docker-ce-cli containerd.io
#5、启动docker
docker systemctl start docker
#6. 使用docker version查看是否按照成功
docker version
#7. 测试
docker run hello-world
```

![image-20211001212054763](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211001212054763.png)

```bash
#7. 测试hello -world
docker run hello-world
```



![image-20211001212313817](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211001212313817.png)

```bash
#8.查看一下下载的镜像
```

![image-20211001212538638](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211001212538638.png)

了解：卸载docker

```bash
#1. 卸载依赖
yum remove docker-ce docker-ce-cli containerd.io
#2. 删除资源
rm -rf /var/lib/docker
# /var/lib/docker 是docker的默认工作路径！
```

## 阿里云镜像加速

1、登录阿里云找到容器服务

![image-20211001213230013](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211001213230013-1633221515436.png)

2、找到镜像加速器

![image-20211001213303923](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211001213303923.png)

**注意选择自己系统对应的镜像加速器**

3、配置使用

```shell
sudo mkdir -p /etc/docker

sudo tee /etc/docker/daemon.json <<-'EOF'
{
  "registry-mirrors": ["https://8sscthmh.mirror.aliyuncs.com"]
}
EOF

sudo systemctl daemon-reload

sudo systemctl restart docker
```

配置完成

![image-20211001213704812](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211001213704812.png)

## 回顾HelloWorld流程

![image-20211001212313817](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211001212313817.png)

**docker run 流程图**

![image-20200515102637246](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjYzNzI0Ni5wbmc)

## 底层原理

Docker**是怎么工作的**？

Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！

Docker-Server接收到Docker-Client的指令，就会执行这个命令！

![image-20211001220053059](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211001220053059-1633221531943.png)

Docker为什么比VM快?

1. Docker有着比虚拟机更少的抽象层
2. Docker利用的是宿主机的内核,vm需要的是Guest OS

![image-20211001220111424](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211001220111424-1633221534681.png)

所以说,新建一个容器的时候,docker不需要像虚拟机一样重新安装一个操作系统内核,虚拟机是加载Guest OS,分钟级别的,而docker是利用宿主机的操作系统,省略了这个复杂的过程

# Docker的常用命令

## 帮助命令

```bash
docker version #docker版本 
docker info #显示docker的系统信息,包括镜像和容器的数量
docker [命令] --help  #查看某个具体的命令
```

## 镜像命令

**docker images 查看下载的所有镜像**

```bash
# docker images
REPOSITORY                TAG                 IMAGE ID            CREATED             SIZE
mysql                     5.6                 8de95e6026c3        20 hours ago        302MB
redis                     latest              36304d3b4540        12 days ago         104MB
mysql                     latest              30f937e841c8        2 weeks ago         541MB
centos/mysql-57-centos7   latest              f83a2938370c        8 months ago        452MB
# 解释
REPOSITORY 镜像的仓库名
TAG 镜像的标签
IMAGE ID 镜像ID
CREATED 镜像创建时间
SIZE 镜像的大小

#可选项
Options:
  -a, --all             #列出所有镜像
  -q, --quiet           #只显示镜像ID
```

**docker search 搜索镜像**

```bash
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker search mysql
NAME	DESCRIPTION									STARS	OFFICIAL	AUTOMATED	
mysql	MySQL is a widely used, open-source relation…  9604     [OK]                

#可选项,通过收藏来过滤
--filter=stars=3000 #搜索出来的镜像收藏就是大于3000的
```

**docker pull 下载镜像**

```bash
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker pull nginx [:tag]
Using default tag: latest #如果不写tag 默认使用最新版本
latest: Pulling from library/nginx
8559a31e96f4: Pull complete  #分层下载,docker image核心 联合文件系统
8d69e59170f7: Pull complete 
3f9f1ec1d262: Pull complete 
d1f5ff4f210d: Pull complete 
1e22bfa8652e: Pull complete 
Digest: sha256:21f32f6c08406306d822a0e6e8b7dc81f53f336570e852e25fbe1e3e3d0d0133 #签名
Status: Downloaded newer image for nginx:latest
docker.io/library/nginx:latest #真实地址

# docker pull nginx 等价于 dicker pull docker.io/library/nginx:latest


#指定版本下载
[root@CZP ~]# docker pull mysql:5.7
```

**docker rmi 删除镜像**

```bash
#  docker rmi -f 镜像id #删除指定的镜像
# docker rmi -f 镜像id 镜像id 镜像id 镜像id#删除指定的镜像
# docker rmi -f $(docker images -aq) #删除全部的镜像
#删除指定的容器
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker rm -f 8de95e6026c3 
#删除全部的容器
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker rm -f $(docker -ap) 
```

## 容器命令

> docker run 镜像id 新建容器并启动
>
> docker ps 列出所有运行的容器 docker container list
>
> docker rm 容器id 删除指定容器
>
> docker start 容器id #启动容器
> docker restart 容器id #重启容器
> docker stop 容器id #停止当前正在运行的容器
> docker kill 容器id #强制停止当前容器

说明：我们有了镜像才可以创建容器，Linux，下载centos镜像来学习

```bash
docker pull [image]
```

**新建容器并启动**

```bash
docker run[可选参数]image
#参数说明
--name="Name"  容器名字tomcat01 tomcat02，用来区分容器
-d 				后台方式运行
-it				使用交互方式运行，进入容器查看内容
-p				指定容器的端口-p8080:8080 
	ip:主机端口:容器端口
	-p主机端口:容器端口（常用)
	-p容器端
	容器端
-P 			随机指定端口

# 测试，启动并进入容器
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker pull centos
Using default tag: latest
latest: Pulling from library/centos
a1d0c7532777: Pull complete
Digest: sha256:a27fd8080b517143cbbbab9dfb7c8571c40d67d534bbdee55bd6c473f432b177
Status: Downloaded newer image for centos:latest
docker.io/library/centos:latest
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
hello-world   latest    feb5d9fea6a5   8 days ago    13.3kB
centos        latest    5d0da3dc9764   2 weeks ago   231MB
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker run -it centos /bin/bash
[root@fcdb9f9e7599 /]# ls  		# 查看容器内的centos，基础版本，很多命令不完善
bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
```

**退出容器**

```bash
exit 	#直接容器停止并退出
ctrl + p + q  	# 直接退出容器，容器不停止
```

**列出所有运行的容器**

```bash
# docker ps 命令
	# 列出当前正在运行的容器
-a	# 列出当前正在运行的容器+历史运行过的容器
-n=?# 显示最近创建的容器
-q	# 只显示容器的编号

# 测试
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps -a
CONTAINER ID   IMAGE         COMMAND       CREATED              STATUS                          PORTS     NAMES
09d5a6a66125   centos        "/bin/bash"   52 seconds ago       Exited (127) 27 seconds ago               modest_lamport
b5dddaa9e101   centos        "/bin/bash"   About a minute ago   Exited (0) About a minute ago             confident_cartwright
fcdb9f9e7599   centos        "/bin/bash"   About an hour ago    Up About an hour                          nifty_elgamal
5331a4375a4b   centos        "/bin/bash"   About an hour ago    Exited (0) About an hour ago              agitated_neumann
99a7099b3eae   hello-world   "/hello"      24 hours ago         Exited (0) 24 hours ago                   confident_ishizaka
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED             STATUS             PORTS     NAMES
fcdb9f9e7599   centos    "/bin/bash"   About an hour ago   Up About an hour             nifty_elgamal
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps -a
CONTAINER ID   IMAGE         COMMAND       CREATED              STATUS                          PORTS     NAMES
09d5a6a66125   centos        "/bin/bash"   About a minute ago   Exited (127) 45 seconds ago               modest_lamport
b5dddaa9e101   centos        "/bin/bash"   About a minute ago   Exited (0) About a minute ago             confident_cartwright
fcdb9f9e7599   centos        "/bin/bash"   About an hour ago    Up About an hour                          nifty_elgamal
5331a4375a4b   centos        "/bin/bash"   About an hour ago    Exited (0) About an hour ago              agitated_neumann
99a7099b3eae   hello-world   "/hello"      24 hours ago         Exited (0) 24 hours ago                   confident_ishizaka
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps -n=1
CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS                            PORTS     NAMES
09d5a6a66125   centos    "/bin/bash"   About a minute ago   Exited (127) About a minute ago             modest_lamport

```

**删除容器**

```bash
docker rm 容器id		# 删除指定容器，不能删除正在运行的容器，如果要强制删除，rm -f
docker rm -f[递归] $(docker ps -aq) #递归删除所有的容器
docker ps -a | xargs docker rm #递归删除所有的容器
```

**启动和停止容器的操作**

```bash
docker start 容器id  #启动容器
docker restart 容器id  #重启容器
docker stop 容器id	#停止当前正在运行的容器
docker kill 容器id 	#强制停止当前容器
```

## 常用的其他命令

**后台启动容器**

```bash
# 命令 docker run -d 镜像名
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker run -d centos
a8f922c255859622ac45ce3a535b7a0e8253329be4756ed6e32265d2dd2fac6c
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps           
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
# 问题docker ps. 发现centos 停止了
# 常见的坑，docker容器使用后台运行，就必须要有要一个前台进程，docker发现没有应用，就会自动停止
# nginx，容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了
```

**查看日志**

```bash
docker logs --help
Options:
      --details        Show extra details provided to logs 
*  -f, --follow         Follow log output
      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)
*      --tail string    Number of lines to show from the end of the logs (default "all")
*  -t, --timestamps     Show timestamps
      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)
➜  ~ docker run -d centos /bin/sh -c "while true;do echo 6666;sleep 1;done" #模拟日志      
#显示日志
-tf		#显示日志信息（一直更新）
--tail number #需要显示日志条数
docker logs -t --tail n 容器id #查看n行日志
docker logs -ft 容器id #跟着日志
```

**查看容器中进程信息** ps

```bash
# 命令 docker top 容器id
```

![image-20211002214059385](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211002214059385.png)

**查看镜像的元数据**

```bash
# 命令
docker inspect 容器id

#测试
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker inspect 917de0b1bebb
[
    {
        "Id": "917de0b1bebb00342e17bcb5500ce1f545a3fc4031cc4dd77b1832283dd51d1e",
        "Created": "2021-10-02T13:39:54.028228273Z",
        "Path": "/bin/bash",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 20883,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2021-10-02T13:39:54.592858909Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6",
        "ResolvConfPath": "/var/lib/docker/containers/917de0b1bebb00342e17bcb5500ce1f545a3fc4031cc4dd77b1832283dd51d1e/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/917de0b1bebb00342e17bcb5500ce1f545a3fc4031cc4dd77b1832283dd51d1e/hostname",
        "HostsPath": "/var/lib/docker/containers/917de0b1bebb00342e17bcb5500ce1f545a3fc4031cc4dd77b1832283dd51d1e/hosts",
        "LogPath": "/var/lib/docker/containers/917de0b1bebb00342e17bcb5500ce1f545a3fc4031cc4dd77b1832283dd51d1e/917de0b1bebb00342e17bcb5500ce1f545a3fc4031cc4dd77b1832283dd51d1e-json.log",
        "Name": "/pedantic_wescoff",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "host",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": false,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/a41e3b368ff7a75cd072397deb899b155d7b1b0df3599a94f22b309fd3104369-init/diff:/var/lib/docker/overlay2/72026f35002ba4704d950cba9cfa102ad1ffae20f6d5f1171edd7c9e72bcf1b6/diff",
                "MergedDir": "/var/lib/docker/overlay2/a41e3b368ff7a75cd072397deb899b155d7b1b0df3599a94f22b309fd3104369/merged",
                "UpperDir": "/var/lib/docker/overlay2/a41e3b368ff7a75cd072397deb899b155d7b1b0df3599a94f22b309fd3104369/diff",
                "WorkDir": "/var/lib/docker/overlay2/a41e3b368ff7a75cd072397deb899b155d7b1b0df3599a94f22b309fd3104369/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "917de0b1bebb",
            "Domainname": "",
            "User": "",
            "AttachStdin": true,
            "AttachStdout": true,
            "AttachStderr": true,
            "Tty": true,
            "OpenStdin": true,
            "StdinOnce": true,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/bash"
            ],
            "Image": "centos",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {
                "org.label-schema.build-date": "20210915",
                "org.label-schema.license": "GPLv2",
                "org.label-schema.name": "CentOS Base Image",
                "org.label-schema.schema-version": "1.0",
                "org.label-schema.vendor": "CentOS"
            }
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "c84b1ce2271a5e0e4afda60977d3a470dd706012f4b6aebeb1cf9875f4946ea5",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/c84b1ce2271a",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "278bd6647092a89eab8ac9198f5e49720dfa89608905c633677121f9d919daf1",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.3",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:03",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "73734a68b1da7873f9573c7e63276006d8748c238a6128d8dc2aef193d9be087",
                    "EndpointID": "278bd6647092a89eab8ac9198f5e49720dfa89608905c633677121f9d919daf1",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.3",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:03",
                    "DriverOpts": null
                }
            }
        }
    }
]
```

**进入当前正在运行的容器**

```bash
# 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置

# 命令 
docker exec -it 容器id bashshell

#测试

[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES
917de0b1bebb   centos    "/bin/bash"   8 minutes ago   Up 8 minutes             pedantic_wescoff
fcdb9f9e7599   centos    "/bin/bash"   2 hours ago     Up 2 hours               nifty_elgamal
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker exec -it 917de0b1bebb /bin.bash
OCI runtime exec failed: exec failed: container_linux.go:380: starting container process caused: exec: "/bin.bash": stat /bin.bash: no such file or directory: unknown
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker exec -it 917de0b1bebb /bin/bash
[root@917de0b1bebb /]# exit
exit
[root@izwz94zhiwnwqwtv5ewlnwz ~]#
```

![image-20211002215033017](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211002215033017.png)

```bash
# 方式二
docker attach 容器id
#测试
docker attach 55321bcae33d 
正在执行当前的代码...
区别
#docker exec #进入当前容器后开启一个新的终端，可以在里面操作。（常用）
#docker attach # 进入容器正在执行的终端
```

**从容器内拷贝到主机上**

```bash
docker cp 容器id:容器内路径   主机目的路径


[root@izwz94zhiwnwqwtv5ewlnwz ~]# ls
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker images
REPOSITORY    TAG       IMAGE ID       CREATED       SIZE
hello-world   latest    feb5d9fea6a5   8 days ago    13.3kB
centos        latest    5d0da3dc9764   2 weeks ago   231MB
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
917de0b1bebb   centos    "/bin/bash"   17 minutes ago   Up 17 minutes             pedantic_wescoff
fcdb9f9e7599   centos    "/bin/bash"   2 hours ago      Up 2 hours                nifty_elgamal
#进入docker容器内部
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker attach 917de0b1bebb
[root@917de0b1bebb /]# cd /home
[root@917de0b1bebb home]# ls
# 在容器内新建一个文件
[root@917de0b1bebb home]# touch test.java
[root@917de0b1bebb home]# exit
exit
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED       STATUS       PORTS     NAMES
fcdb9f9e7599   centos    "/bin/bash"   2 hours ago   Up 2 hours             nifty_elgamal
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps -a
CONTAINER ID   IMAGE         COMMAND       CREATED          STATUS                        PORTS     NAMES
917de0b1bebb   centos        "/bin/bash"   18 minutes ago   Exited (0) 21 seconds ago               pedantic_wescoff
09d5a6a66125   centos        "/bin/bash"   44 minutes ago   Exited (127) 44 minutes ago             modest_lamport
b5dddaa9e101   centos        "/bin/bash"   45 minutes ago   Exited (0) 45 minutes ago               confident_cartwright
fcdb9f9e7599   centos        "/bin/bash"   2 hours ago      Up 2 hours                              nifty_elgamal
5331a4375a4b   centos        "/bin/bash"   2 hours ago      Exited (0) 2 hours ago                  agitated_neumann
99a7099b3eae   hello-world   "/hello"      25 hours ago     Exited (0) 25 hours ago                 confident_ishizaka
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker cp 917de0b1bebb:/home/test.java /home
[root@izwz94zhiwnwqwtv5ewlnwz ~]# ls
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker cp fcdb9f9e7599:/home/test.java /home
Error: No such container:path: fcdb9f9e7599:/home/test.java
# 将这个文件拷贝出来到主机上
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker cp 917de0b1bebb:/home/test.java /home
[root@izwz94zhiwnwqwtv5ewlnwz ~]# ls
[root@izwz94zhiwnwqwtv5ewlnwz ~]# cd /home
# 查看
[root@izwz94zhiwnwqwtv5ewlnwz home]# ls
git  redis  test.java  www

# 拷贝是一个手动过程，未来我们使用 -V 卷的技术，可以实现自动同步，容器中的/home  和主机/home 同步
```

## **小结：**

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619182742864.png)

```bash
attach      Attach  to a running container # 进入容器内部,不启动新的进程
  build       Build an image from a Dockerfile # 通过dockerfile 定制镜像
  commit      Create a new image from a container's changes #提交当前容器为新的镜像
  cp          Copy files/folders between a container and the local filesystem #从容器中拷贝指定的文件或者目录到宿主机上
  create      Create a new container # 创建一个新的容器,同run 但不启动容器
  diff        Inspect changeson a container's filesystem # 查看docker容器变化
  events      Get real time events from the server# 从docker服务获取容器实时事件
  exec        Run a command in a running container# 在已存在的容器上运行命令
  export      Export a container's filesystem as a tar archive
  history     Show the history of an image
  images      List images
  import      Import the contents from a tarball to create a filesystem image
  info        Display system-wide information
  inspect     Return low-level information on Docker objects
  kill        Kill one or more running containers
  load        Load an image from a tar archive or STDIN
  login       Log in to a Docker registry
  logout      Log out from a Docker registry
  logs        Fetch the logs of a container
  pause       Pause all processes within one or more containers
  port        List port mappings or a specific mapping for the container
  ps          List containers
  pull        Pull an image or a repository from a registry
  push        Push an image or a repository to a registry
  rename      Rename a container
  restart     Restart one or more containers
  rm          Remove one or more containers
  rmi         Remove one or more images
  run         Run a command in a new container
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  search      Search the Docker Hub for images
  start       Start one or more stopped containers
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop one or more running containers
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE
  top         Display the running processes of a container
  unpause     Unpause all processes within one or more containers
  update      Update configuration of one or more containers
  version     Show the Docker version information
  wait        Block until one or more containers stop, then print their exit codes
```

## 案例：

> Docker 安装Nginx

```bash
#1. 搜索镜像 search 建议大家去docker搜索，可以看到帮助文档
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker search nginx
#2. 拉取镜像 pull
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker pull  nginx
#3、运行测试
# -d 后台运行
# --name 给容器命名
# -p 宿主机端口：容器内部端口
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker  run -d --name nginx01 -p 3344:80 nginx
56a061396ea33d2bfe93645ebecc316eeb0bbc090de29b132631d8edf45b20bc
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS         PORTS                  NAMES
56a061396ea3   nginx     "/docker-entrypoint.…"   10 seconds ago   Up 7 seconds   0.0.0.0:3344->80/tcp   nginx01
[root@izwz94zhiwnwqwtv5ewlnwz ~]# curl localhost:3344
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
<style>
html { color-scheme: light dark; }
body { width: 35em; margin: 0 auto;
font-family: Tahoma, Verdana, Arial, sans-serif; }
</style>
</head>
<body>
<h1>Welcome to nginx!</h1>
<p>If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.</p>

<p>For online documentation and support please refer to
<a href="http://nginx.org/">nginx.org</a>.<br/>
Commercial support is available at
<a href="http://nginx.com/">nginx.com</a>.</p>

<p><em>Thank you for using nginx.</em></p>
</body>
</html>
```

思考问题：我们每次改动nginx配置文件，都需要进入容器内部？十分的麻烦，要是可以在容器外部提供一个映射路径，达到在容器修改文件名，容器内部就可以自动修改？√数据卷！

![img](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDIxNTkxNTY1MC5wbmc)

> Docker 来装一个tomcat

```bash
# 官方的使用
docker run -it --rm tomcat:9.0
# 之前的启动都是后台，停止了容器，容器还是可以查到， docker run -it --rm image 一般是用来测试，用完就删除
--rm       Automatically remove the container when it exits
#下载最新版
docker pull tomcat
#启动运行
docker run -d -p 3355:8080 --name tomcat01 tomcat
#测试访问有没有问题
curl 3355:8080

#进入容器
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                    NAMES
db09851cf82e        tomcat              "catalina.sh run"   28 seconds ago      Up 27 seconds       0.0.0.0:8080->8080/tcp   tomcat01
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker exec -it db09851cf82e /bin/bash             
root@db09851cf82e:/usr/local/tomcat# 
# 发现问题：1、linux命令少了。 2.没有webapps。 	阿里云镜像的原因，默认是最小镜像，所有不必要的都被删除掉了。
# 保证最小可运行的环境。
```

思考问题：我们以后要部署项目，如果每次都要进入容器是不是十分麻烦？要是可以在容器外部提供一个映射路径，如：webapps，我们在外部放置项目，就自动同步内部就好了！

> Docker 部署es+kibana

```bash
# es 暴露的端口很多！
# es 的数据一般需要放置到安全目录！挂载
# --net somenetwork ? 网络配置

# 启动elasticsearch
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" elasticsearch:7.6.2
# 测试一下es是否成功启动
[root@izwz94zhiwnwqwtv5ewlnwz ~]# curl localhost:9200
{
  "name" : "d73ad2f22dd3",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "atFKgANxS8CzgIyCB8PGxA",
  "version" : {
    "number" : "7.6.2",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
# 启动es之后Linux很卡，
# 查看docker容器使用内存情况
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker stats 

CONTAINER ID        NAME                CPU %               MEM USAGE / LIMIT   MEM %               NET I/O             BLOCK I/O           PIDS
bd4094db247f        elasticsearch       1.57%               1.226GiB / 3.7GiB   33.13%              0B / 0B             0B / 0B             42
94b00b6f6172        tomcat              0.18%               78.58MiB / 3.7GiB   2.07%               1.69kB / 2.47kB     0B / 0B             37
d458bc50a808        nginx01             0.00%               1.883MiB / 3.7GiB   0.05%               5.22kB / 6.32kB     0B / 0B             3
63d4c4115212        redis               0.14%               9.637MiB / 3.7GiB   0.25%               10.8kB / 14.2kB     0B / 0B             7
# es 是十分耗内存的，1.xG,
# 查看cpu使用情况，docker stats
# 关闭es ，增加内存限制
```

![image-20211002230857726](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211002230857726.png)

```bash
#elasticsearch十分占用内存,需要修改配置文件 -e 限制其启动的内存
docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS= 
"-Xms64m -Xmx 512m"  elasticsearch:7.6.2
```

![image-20211002230904586](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211002230904586.png)

```bash

[root@izwz94zhiwnwqwtv5ewlnwz ~]#curl localhost:9200
{
  "name" : "bd4094db247f",
  "cluster_name" : "docker-cluster",
  "cluster_uuid" : "U3TfPp1rQ6uitn0WMh6pRQ",
  "version" : {
    "number" : "7.6.2",
    "build_flavor" : "default",
    "build_type" : "docker",
    "build_hash" : "ef48eb35cf30adf4db14086e8aabd07ef6fb113f",
    "build_date" : "2020-03-26T06:34:37.794943Z",
    "build_snapshot" : false,
    "lucene_version" : "8.4.0",
    "minimum_wire_compatibility_version" : "6.8.0",
    "minimum_index_compatibility_version" : "6.0.0-beta1"
  },
  "tagline" : "You Know, for Search"
}
```

> docker和kibana如何连接

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619182808443.png)

# 可视化

- portainer(先用这个)

```bash
docker run -d -p 8088:9000 \
--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
```

- Rancher(CI/CD再用)

**什么是portainer？**

Docker图形化界面管理工具！提供一个后台面板供我们操作！

```bash
docker run -d -p 8088:9000 \
--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer
```

![image-20211003081239676](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003081239676.png)

访问测试：外网：http://ip:8088/（外网ip）

访问结果：

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619182828579.png)

单机版这里选择local即可，选择完毕，点击Connect即可连接到本地docker

![img](28.Docker%E5%9F%BA%E7%A1%80.assets/7232803-8179a3e34bc5fb25.png)

进入之后的面板

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619182840991.png)

内网访问：`curl localhost:8088`

![image-20211003081526864](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003081526864.png)

# Docker镜像讲解

## 镜像是什么

镜像就是一个轻量级的,可执行的独立软件包,用来打包软件运行环境和基于运行环境开发的软件,它包含运行某个软件所需的所有内容,包括代码,运行时,库,环境变量和配置文件。

所有的应用,直接打包docker镜像,就可以直接跑起来!

**如何得到镜像:**

- 从远程仓库下载
- 朋友拷贝给你
- 自己制作一个镜像 DockerFile

## Docker镜像加载原理

> UnionFs(联合文件系统查询)

我们下载镜像的时候看到的一层一层就是这个

UnionFs(联合文件系统): Union文件系统(UnionFS)是一种分层,轻量级并且高性能的文件系统,它支持对文件系统的修改作为一次提交来一层层的叠加,同时可以将不同目录挂载到同一个虚拟文件系统下,Union文件系统是Docker镜像的基础,镜像可以通过分层来进行继承,基于基础镜像(没有父镜像),可以制作各种具体的应用镜像

特性: 一次同时加载多个文件系统,但从外面看起来,只能看到一个文件系统,联合加载会把各层文件系统叠加起来,这样最终的文件系统会包含所有底层的文件和目录结构

> Docker镜像加载原理

docker的镜像实际上由一层一层的文件系统组成,这种层级的文件系统UnionFS

bootfs(boot file system)主要包含bootlloader和kernel,bootfs主要是引导加载kernel,Linux刚启动时会加载bootfs文件系统,在docker镜像的最底层是bootfs,这一层与我们典型的Linux/Unix系统是一样的,包含boot加载器和内核,当boot加载完成之后整个内核就在内存中了,此时内存的使用权已由bootfa转交给内核,此时系统也会卸载bootfs

rootfs(root file system),在bootfs之上,包含的就是典型Linux系统中的/dev, /proc,/bin, /etc等标准目录和文件,rootfs就是各种不同的操作系统发行版,比如Ubuntu, CentOS等等

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619182900538.png)

平时我们安装进虚拟机的CentOS都是好几个G,为什么Docker这里才200M?

![image-20211003082516702](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003082516702.png)

对于一个精简的OS,rootfs可以很小,只需要包含基本的命令,工具和程序库就可以了,因为底层直接用Host的kernel,自己只需要提供rootFS就可以了。由此可见对于不同的linux发行版,bootfs基本是一致的,rootfs会有差别,因此不同的发行版可以共用bootfs

## 分层理解

> 分层的镜像

我们可以去下载一个镜像,注意观察下载的日志输出,可以看到是一层一层的在下载!

![image-20211003082835314](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003082835314.png)

思考: 为什么Docker镜像要采用这种分层的结构呢?

最大好处,我觉得莫过于资源共享了!比如有多个镜像都从相同的Base镜像构建而来,那么宿主机

只需在磁盘上保留一份base镜像,同时内存中也只需要加载一份base镜像,这样就可以为所有的容器服务了,而且镜像的每一层都可以被共享

查看镜像分层的方式可以通过 `docker image inspect` 命令!

```bash
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker image inspect redis
[
        "RootFS": {
            "Type": "layers",
            "Layers": [
                "sha256:476baebdfbf7a68c50e979971fcd47d799d1b194bcf1f03c1c979e9262bcd364",
                "sha256:93d8d4a5991327cff0ae3ba393d09dee2f54b0cd04984595a0b252cfc7804c64",
                "sha256:ba43519ed653c0218d58f015140bd569ccb858a74d957662555aa59f148e4e9c",
                "sha256:4b32cd47950d5e6292339316541a6525d6a9ad9acbf44db07f1b06a8d20c72de",
                "sha256:8d8b11b854499a81491a636a678b676b76fd755bae77c20a9e9a6c978b761ba2",
                "sha256:cbdf3b39c39900df877106713a0b8a9c7cf36926143215a54259fe51f0c92176"
            ]
        },
        "Metadata": {
            "LastTagTime": "0001-01-01T00:00:00Z"
        }
    }
]
```

**理解:**

所有的镜像都起始于一个基础镜像层,当进行修改或增加新的内容时,就会在当前镜像层之上,创建一个新的镜像层,

举一个简单的例子,假如基于Ubuntu Linux 16.64创建一个新的镜像,这就是新镜像的第一层,如果在该镜像中添加python包,就会在该镜像之上创建第二个镜像层; 如果继续添加一个安全补丁,就会创建第三个镜像层

该镜像已经包含3个镜像层,如下图所示(这只是一个简单的例子)

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/202006191829432.png)

在添加额外的镜像层的同时,镜像始终保持是当前所有镜像的组合,理解这一点非常重要,下图举了一个简单的例子,每个镜像层包含3个文件,而镜像包含了两个镜像层的6个文件

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/2020061918295560.png)

上图中的镜像层跟之前图中的略有区别,主要是便于展示文件

下图中展示了一个稍微复杂的三层镜像,在外部看来整个镜像只有6个文件,这是因为最上层的文件7是文件5的一个更新版本

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619183009764.png)

这种情况下,上层镜像层中的文件覆盖了底层镜像层中的文件,这样就使得文件的更新版本作为一个新镜像层添加到镜像当中

Docker通过存储引擎(新版本采用快照机制)的方式来实现镜像层堆栈,并保证多层镜像层对外展示为统一的文件系统

Lunux上可用的存储引擎有AUFS,Overlay2,Device Mapper,Btrfs以及ZFS,顾名思义,每种存储引擎都是基于Linux对应的文件系统或者块设备技术,并且每种存储引擎都有其独有的性能特点

Docker在Windows上仅支持windosfilter一种存储引擎,该引擎基于NTFS文件系统之上实现了分层和CoW[1]

下图展示了与系统显示相同的三层镜像,所有的镜像层堆叠合并,对外提供统一的视图层

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619183024727.png)

> 特点

Docker镜像都是只读的,当容器启动时,一个新的可写层被加载到镜像的顶部!

这一层就是我们通常所说的容器层,容器之下的都叫镜像层

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619183036853.png)

如何提交一个自己的镜像

## commit镜像

```bash
docker commit 提交容器成为一个新的镜像

#命令和git原理类似
docker commit -m="提交的描述信息" -a="作者" 容器ID 目标镜像名:[tag]
```

实战测试

```bash
# 1、启动一个默认的tomcat
docker run -d -p 8080:8080 tomcat
# 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！
docker exec -it 容器id
# 3、拷贝文件进去

# 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像。
docker commit -m="描述信息" -a="作者" 容器id 目标镜像名:[TAG]
docker commit -a="zyc" -m="add webapps app" 容器id tomcat02:1.0
```

如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。

启动tomcat：

![image-20211003090019017](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003090019017.png)

新开一个窗口：

![image-20211003085953167](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003085953167.png)

```bash
# 查看tomcat运行状态
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker ps
CONTAINER ID   IMAGE     COMMAND             CREATED         STATUS         PORTS                    NAMES
b798eb5556ee   tomcat    "catalina.sh run"   2 minutes ago   Up 2 minutes   0.0.0.0:8080->8080/tcp   heuristic_keller
# 进入tomcat
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker exec -it b798eb5556ee /bin/bash
root@b798eb5556ee:/usr/local/tomcat# cd webapps
# 发现webapps下面没有应用
root@b798eb5556ee:/usr/local/tomcat/webapps# ls
root@b798eb5556ee:/usr/local/tomcat/webapps# cd ..
root@b798eb5556ee:/usr/local/tomcat# ls
BUILDING.txt     LICENSE  README.md      RUNNING.txt  conf  logs            temp     webapps.dist
CONTRIBUTING.md  NOTICE   RELEASE-NOTES  bin          lib   native-jni-lib  webapps  work
# 拷贝应用进入
root@b798eb5556ee:/usr/local/tomcat# cp -r webapps.dist/* webapps
root@b798eb5556ee:/usr/local/tomcat# cd webapps
root@b798eb5556ee:/usr/local/tomcat/webapps# ls
ROOT  docs  examples  host-manager  manager
root@b798eb5556ee:/usr/local/tomcat/webapps# docker commit -a="zyc" -m="add webapps app" b798eb5556ee tomcat9:1.0
bash: docker: command not found
# 退出tomcat
root@b798eb5556ee:/usr/local/tomcat/webapps# exit
exit
# 将操作过的容器通过commit调教为一个镜像！我们以后就使用我们修改过的镜像即可，这就是我们自己的一个修改的镜像。
[root@izwz94zhiwnwqwtv5ewlnwz ~]#  docker commit -a="zyc" -m="add webapps app" b798eb5556ee tomcat9:1.0
sha256:c407938ef98f4d928ac4b8dc4642eaf154391feefc19e87555b2f0b43ef8b046
[root@izwz94zhiwnwqwtv5ewlnwz ~]#
# 查看自己提交的镜像
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker images
REPOSITORY            TAG       IMAGE ID       CREATED          SIZE
tomcat9               1.0       c407938ef98f   14 seconds ago   684MB
tomcat                latest    c662ee449a7e   3 days ago       680MB
redis                 latest    5d89766432d0   4 days ago       105MB
nginx                 latest    f8f4ffc8092c   4 days ago       133MB
hello-world           latest    feb5d9fea6a5   9 days ago       13.3kB
centos                latest    5d0da3dc9764   2 weeks ago      231MB
portainer/portainer   latest    580c0e4e98b0   6 months ago     79.1MB
elasticsearch         7.6.2     f29a1ee41030   18 months ago    791MB
elasticsearch         latest    5acf0e8da90b   3 years ago      486MB

```

# 容器数据卷

## 什么是容器数据卷

**docker的理念回顾**

将应用和环境打包成一个镜像!

如果数据都在容器中,那么我们容器删除,数据就会丢失! ==需求: 数据可以持久化==

MYSQL, 容器删了,删库跑路! ==需求: mysql数据可以存储在本地!==

容器之间可以有一个数据共享的技术! Docker 容器中产生的数据,同步到本地!

这就是卷技术! 目录的挂载,将容器内的目录挂载到Linux上面!

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619183052229.png)

**总结一句话: 容器的持久化和同步操作! 容器间也可以数据共享的!**（Linux中/home/mysql文件夹与容器中/usr/mysql文件夹中的自动双向同步）

## 使用数据卷

> 方式一: 直接使用命令来挂载 -v   等价于Vue中的双向绑定

```bash
docker run -it -v 主机目录: 容器内目录  -p 主机端口: 容器端口

# 启动起来我们可以使用 docker inspect 容器id
```

测试文件同步：

![image-20211003093856813](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003093856813.png)

![image-20211003093912338](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003093912338.png)

使用`docker insepect`命令查看：
![image-20211003094114772](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003094114772.png)

## 实战: 安装Mysql

思考: mysql的数据持久化的问题, data目录

```bash
#获取镜像

[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker pull mysql:5.7



# 运行容器,需要做数据挂载! # 安装启动mysql,需要配置密码,这是官方的
# 官方测试: docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=密码 -d mysql:tag

#启mysql
-d  后台运行
-p  端口映射
-v  端口映射
-e  环境配置
--name 容器名

[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=zyc766623393 --name mysql01 mysql:5.7


# 启动成功之后,我们在本地使用sqlyog来连接测试一下

#sqlyog-连接到服务器的端口 ---服务器端口和容器端口映射,这个时候我们就可以连接上了

# 在本地创建一个数据库，查看映射路径是否正确
```

![image-20211003095739061](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003095739061.png)

假设我们将容器删除

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619183120835.png)

发现,我们挂载到本地的数据卷依旧没有丢失,这就实现了容器数据持久化功能

## 具名挂载和匿名挂载

```bash
# 匿名挂载
-v 容器内路径!
[root@izwz94zhiwnwqwtv5ewlnwz ~]# docker run -d -P --name niming-nginx -v /etc/nginx nginx


#查看所有的卷的情况
[root@izwz94zhiwnwqwtv5ewlnwz ~]# cd /home
[root@izwz94zhiwnwqwtv5ewlnwz home]# docker volume ls
DRIVER    VOLUME NAME
local     14a74961061a543a82bbb8f58e4bd9de4512f6bbb026b4817664103ef905f571
local     3829f78421a6ec3b7804d242aaccb63791917541ae08132f337c287a589a7c3c
local     e6cdc909e92179f4c08323b2fc59178e8bdadbfd00cc333f3d193a02258e5920


#这里发现,这种就是匿名挂载, 我们在 -v只写了容器内的路径,没有写容器外的路径


#具名挂载
[root@izwz94zhiwnwqwtv5ewlnwz home]# docker run -d -P --name jm-nginx -v juming-niginx:/etc/niginx nginx
856ec6981c8d56beb6be570f600580df78d4a7167ff04de544056868f6d54d3b
[root@izwz94zhiwnwqwtv5ewlnwz home]# docker volume ls
DRIVER    VOLUME NAME
local     14a74961061a543a82bbb8f58e4bd9de4512f6bbb026b4817664103ef905f571
local     3829f78421a6ec3b7804d242aaccb63791917541ae08132f337c287a589a7c3c
local     e6cdc909e92179f4c08323b2fc59178e8bdadbfd00cc333f3d193a02258e5920
local     juming-niginx

# 通过 -v 卷名:容器内路径
# 查看一下这个卷
```



![image-20211003104620069](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003104620069.png)

所有的docker容器内的卷,没有指定目录的情况下都是在==/var/lib/docker/volumes/卷名/_data==

我们通过具名挂载可以方便的找到一个卷,大多数情况在使用的`具名挂载`

```bash
# 如何确定是具名挂载还是匿名挂载,还是指定路径挂载
-v 容器内路径 #匿名挂载
-v 卷名:容器内路径 #具名挂载
-v 宿主机路径 : 容器内路径 #指定路径挂载
```

扩展：

```bash
#通过 -v  容器内路径: ro rw 改变读写权限
ro read only
read and write

#一旦设置了容器权限,容器对挂载出来的内容就有限定了!
docker run -d -P --name jm-nginx -v juming-niginx:/etc/niginx:ro nginx
docker run -d -P --name jm-nginx -v juming-niginx:/etc/niginx:rw nginx
# ro : 只要看到ro就说明这个路径只能通过宿主机来改变,容器内部无法操作
```

## 初始Dockerfile

Dockerfile就是用来构建Dockerfile镜像的文件! 命令脚本!

![image-20211003112751487](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003112751487.png)



```bash
# 创建一个dockerfile文件,名字可以随机 建议 dockerfile
# 文件中的内容

FROM centos

VOLUME ["volume01","volume02"]

CMD echo "---end---"
CMD /bin/hash
```

![image-20211003112905097](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003112905097.png)

![image-20211003113126863](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211003113126863.png)

这个卷和外部一定有一个同步的目录

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619183210681.png)

查看一下卷挂载的路径

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619183221422.png)

测试一下刚才的文件是否同步出去了

这种方式我们未来使用的十分多,因为我们通常会构建自己的镜像!

假设构建镜像时没有挂载卷,要手动镜像挂载 -v 卷名: 容器内路径

## **数据卷容器**

两个Mysql同步数据!

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619183235195.png)

```bash
--volumes-from list              Mount volumes from the specified container(s)
# 测试，我们通过刚才启动的
```

![image-20200516123020050](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzAyMDA1MC5wbmc)



![image-20200516123128475](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzEyODQ3NS5wbmc)

```bash
# 测试：可以删除docker01，查看一下docker02和docker03是否可以访问这个文件
# 测试依旧可以访问
```

![image-20200516123355034](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMzM1NTAzNC5wbmc)

多个mysql实现数据共享

```bash
docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7
docker run -d -p 3307:3306 -e MYSQL_ROOT_PASSWORD=123456 --name mysql02 --volumes-from mysql01  mysql:5.7
# 这个时候，可以实现两个容器数据同步！
```

结论：

容器之间的配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。

但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的！

# DockerFile

## DockerFile介绍

`dockerfile`是用来构建docker镜像的文件！命令参数脚本！

构建步骤：

1、 编写一个dockerfile文件

2、 docker build 构建成为一个镜像

3、 docker run运行镜像

4、 docker push发布镜像（DockerHub 、阿里云仓库)

![image-20200516131400456](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEzMTQwMDQ1Ni5wbmc)

点击后跳到一个Dockerfile

![image-20200516131441750](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEzMTQ0MTc1MC5wbmc)

很多官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像！

官方既然可以制作镜像，那我们也可以！

## DockerFile构建过程

**基础知识：**

1、每个保留关键字(指令）都是必须是大写字母

2、指令执行从上到下顺序

3、#表示注释

4、每一个指令都会创建提交一个新的镜像曾，并提交！

![image-20200516131756997](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEzMTc1Njk5Ny5wbmc)

Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！

Docker镜像逐渐成企业交付的标准，必须要掌握！

DockerFile：构建文件，定义了一切的步骤，源代码

DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。

Docker容器：容器就是镜像运行起来提供服务。

## DockerFile的指令

```bash
FROM				# 基础镜像，一切从这里开始构建
MAINTAINER			# 镜像是谁写的， 姓名+邮箱
RUN					# 镜像构建的时候需要运行的命令
ADD					# 步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录
WORKDIR				# 镜像的工作目录
VOLUME				# 挂载的目录
EXPOSE				# 保留端口配置
CMD					# 指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代。
ENTRYPOINT			# 指定这个容器启动的时候要运行的命令，可以追加命令
ONBUILD				# 当构建一个被继承 DockerFile 这个时候就会运行ONBUILD的指令，触发指令。
COPY				# 类似ADD，将我们文件拷贝到镜像中
ENV					# 构建的时候设置环境变量！
```

![img](28.Docker%E5%9F%BA%E7%A1%80.assets/aHR0cHM6Ly9zczAuYmRzdGF0aWMuY29tLzcwY0Z1SFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTI2ODk3NDY0OSwyNjA3MDE5OTExJmZtPTI2JmdwPTAuanBn-1633256861929)

## 实战测试

Docker Hub 中99%镜像都是从centos基础镜像过来的 FROM scratch,然后配置需要的软件和配置来构建

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184350120.png)

> 创建一个自己的centos

```bash
# 1 编写一个Dockerfile的文件

[root@izwz94zhiwnwqwtv5ewlnwz ~]# ls
[root@izwz94zhiwnwqwtv5ewlnwz ~]# cd /home
[root@izwz94zhiwnwqwtv5ewlnwz home]# ls
ceshi  docker-test-volume  git  mysql  redis  test.java  www
[root@izwz94zhiwnwqwtv5ewlnwz home]# mkdir dockerfile
[root@izwz94zhiwnwqwtv5ewlnwz home]# cd dockfile
-bash: cd: dockfile: No such file or directory
[root@izwz94zhiwnwqwtv5ewlnwz home]# cd dockfile/
-bash: cd: dockfile/: No such file or directory
[root@izwz94zhiwnwqwtv5ewlnwz home]# cd dockerfile
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# vim mydockerfile
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# cat mydockerfile
FROM centos

MAINTAINER zyc<766623393@qq.com>

ENV MYPATH /usr/local

WORKDIR $MYPATH

RUN yum -y  install vim
RUN yum -y install net-tools

EXPOSE 80

CMD echo $MYPATH
CMD echo "---end---"


# 2. 通过这个文件构建镜像
# 命令 docker build -f dockerfile文件路径 -t
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# docker build -f mydockerfile -t mycentos:1.0 .
Sending build context to Docker daemon  2.048kB
Step 1/9 : FROM centos


Successfully built 2fff7896a096
Successfully tagged mycentos:1.0


# 3. 测试运行
```

增强之后的镜像

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184405292.png)

我们可以列出本地进程的历史

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184416447.png)

我们平时拿到一个镜像,可以研究一下它是怎么做的

> CMD 和ENTRYPOINT的区别

```bash
CMD # 指定这个容器启动的时候要运行的命令,只有最后一个会生效,可被替代
ENTRYPOINT # 指定这个容器启动的时候要运行的命令,可以追加命令
```

测试cmd命令

```bash
# 编写dockerfile
[root@izwz94zhiwnwqwtv5ewlnwz ~]# ls
[root@izwz94zhiwnwqwtv5ewlnwz ~]# cdhome
-bash: cdhome: command not found
[root@izwz94zhiwnwqwtv5ewlnwz ~]# cd home
-bash: cd: home: No such file or directory
[root@izwz94zhiwnwqwtv5ewlnwz ~]# cd /home
[root@izwz94zhiwnwqwtv5ewlnwz home]# ;s
-bash: syntax error near unexpected token `;'
[root@izwz94zhiwnwqwtv5ewlnwz home]# ls
ceshi  dockerfile  docker-test-volume  git  mysql  redis  test.java  www
[root@izwz94zhiwnwqwtv5ewlnwz home]# cd dockerfile
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# ls
mydockerfile
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# vim mydockerfile-cmd-test
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# cat mydockerfile-cmd-test
FROM centos
CMD ["ls","-a"]



# 构建镜像
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest
"docker build" requires exactly 1 argument.
See 'docker build --help'.

Usage:  docker build [OPTIONS] PATH | URL | -

Build an image from a Dockerfile
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# docker build -f dockerfile-cmd-test -t cmdtest .
unable to prepare context: unable to evaluate symlinks in Dockerfile path: lstat /home/dockerfile/dockerfile-cmd-test: no such file or directory
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# ls
mydockerfile  mydockerfile-cmd-test
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# docker build -f mydockerfile-cmd-test -t cmdtest .
Sending build context to Docker daemon  3.072kB
Step 1/2 : FROM centos
 ---> 5d0da3dc9764
Step 2/2 : CMD ["ls","-a"]
 ---> Running in b240eddad99e
Removing intermediate container b240eddad99e
 ---> 041ac03f37cb
Successfully built 041ac03f37cb
Successfully tagged cmdtest:latest

# 直接运行
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# docker run 041ac03f37cb
.
..
.dockerenv
bin
dev
etc
home
lib
lib64
lost+found
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var

# 想要追加一个命令 -l  ls -al
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# docker run 041ac03f37cb -l
docker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: exec: "-l": executable file not found in $PATH: unknown.


# cmd的情况下 替换了CMD["ls","-a"]命令,-不是命令追加


[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# docker run 041ac03f37cb ls -al
total 56
drwxr-xr-x   1 root root 4096 Oct  3 11:41 .
drwxr-xr-x   1 root root 4096 Oct  3 11:41 ..
-rwxr-xr-x   1 root root    0 Oct  3 11:41 .dockerenv
lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -> usr/bin
drwxr-xr-x   5 root root  340 Oct  3 11:41 dev
drwxr-xr-x   1 root root 4096 Oct  3 11:41 etc
drwxr-xr-x   2 root root 4096 Nov  3  2020 home
lrwxrwxrwx   1 root root    7 Nov  3  2020 lib -> usr/lib
lrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -> usr/lib64
drwx------   2 root root 4096 Sep 15 14:17 lost+found
drwxr-xr-x   2 root root 4096 Nov  3  2020 media
drwxr-xr-x   2 root root 4096 Nov  3  2020 mnt
drwxr-xr-x   2 root root 4096 Nov  3  2020 opt
dr-xr-xr-x 147 root root    0 Oct  3 11:41 proc
dr-xr-x---   2 root root 4096 Sep 15 14:17 root
drwxr-xr-x  11 root root 4096 Sep 15 14:17 run
lrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Nov  3  2020 srv
dr-xr-xr-x  13 root root    0 Oct  3 11:41 sys
drwxrwxrwt   7 root root 4096 Sep 15 14:17 tmp
drwxr-xr-x  12 root root 4096 Sep 15 14:17 usr
drwxr-xr-x  20 root root 4096 Sep 15 14:17 var

```

ENTRYPOINT是往命令之后追加

```bash
[root@izwz94zhiwnwqwtv5ewlnwz dockerfile]# docker run 041ac03f37cb -l
total 56
drwxr-xr-x   1 root root 4096 Oct  3 11:41 .
drwxr-xr-x   1 root root 4096 Oct  3 11:41 ..
-rwxr-xr-x   1 root root    0 Oct  3 11:41 .dockerenv
lrwxrwxrwx   1 root root    7 Nov  3  2020 bin -> usr/bin
drwxr-xr-x   5 root root  340 Oct  3 11:41 dev
drwxr-xr-x   1 root root 4096 Oct  3 11:41 etc
drwxr-xr-x   2 root root 4096 Nov  3  2020 home
lrwxrwxrwx   1 root root    7 Nov  3  2020 lib -> usr/lib
lrwxrwxrwx   1 root root    9 Nov  3  2020 lib64 -> usr/lib64
drwx------   2 root root 4096 Sep 15 14:17 lost+found
drwxr-xr-x   2 root root 4096 Nov  3  2020 media
drwxr-xr-x   2 root root 4096 Nov  3  2020 mnt
drwxr-xr-x   2 root root 4096 Nov  3  2020 opt
dr-xr-xr-x 147 root root    0 Oct  3 11:41 proc
dr-xr-x---   2 root root 4096 Sep 15 14:17 root
drwxr-xr-x  11 root root 4096 Sep 15 14:17 run
lrwxrwxrwx   1 root root    8 Nov  3  2020 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Nov  3  2020 srv
dr-xr-xr-x  13 root root    0 Oct  3 11:41 sys
drwxrwxrwt   7 root root 4096 Sep 15 14:17 tmp
drwxr-xr-x  12 root root 4096 Sep 15 14:17 usr
drwxr-xr-x  20 root root 4096 Sep 15 14:17 var
```

## 发布自己的镜像

> DockerHub

1. 地址hub.docker.com 注册自己的账号!
2. 确定这个账号可以登录
3. 在服务器上提交自己的镜像

```bash
[root@CZP ~]# docker login --help

Usage:	docker login [OPTIONS] [SERVER]

Log in to a Docker registry.
If no server is specified, the default is defined by the daemon.

Options:
  -p, --password string   Password
      --password-stdin    Take the password from stdin
  -u, --username string   Username
```

4. 登录完毕就可以提交镜像了,就是一步 docker push

```bash
#push自己的镜像到服务器上一定要带上版本号
[root@CZP ~]# docker push czp/centos:1.0


docker tag [id] [tag] 为容器添加一个版本
```

> 提交到阿里云镜像仓库

1. 登录阿里云
2. 找到容器镜像服务
3. 创建命名空间

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184533739.png)

4. 创建容器镜像

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184546684.png)

5. 浏览阿里云

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/2020061918455938.png)

## 小结

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184610970.png)

# Docker网络

理解docker0

> 测试

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184654885.png)

三个网络

```bash
# 问题: docker 是如何处理容器网络访问的?
```

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184742153.png)

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184814123.png)

> 原理

1. 我们每启动一个docker容器,docker就会给docker容器分配一个ip,我们只要安装了docker,就会有一个网卡docker0,桥接模式,使用的技术是evth-pair技术!

再次测试 ip addr

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/2020061918485148.png)

2. 再启动一个容器

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184905708.png)

```bash
# 我们发现这个容器带来网卡, 都是一对对的
# evth-pair 就是一对虚拟机设备接口,他们都是成对出现的,一端连着协议,一端彼此相连
# 正因为有这个特性,veth-pair 充当桥梁,连接各种虚拟网络设备的
# openStac,Docker容器之间的连接,OVS的连接,都是使用 evth-pair 技术
```

3. 我们来测试一

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184921826.png)

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184934900.png)

结论: tomcat01和tomcat02是共用的一个路由器,docker0

所有的容器不指定网络的情况下,都是docker0路由的,docker会给我们的容器分配一个默认的可用IP

> 小结

Docker 使用的是Linux的桥接,宿主机中是一个Docker容器的网桥,docker0

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619184949651.png)

Docker中所有的网络接口都是虚拟的,虚拟的转发效率高

只要容器删除,对应网桥的一对就没了

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619185002288.png)

## --link

> 思考一个场景,我们编写了一个微服务,database url=ip: 项目不重启,数据库IP换掉了,我们希望可以通过名字来访问服务

```bash
[root@CZP ~]# docker exec -it tomcat02 ping tomcat01
ping: tomcat01: Name or service not known

# 如何可以解决呢?


# 通过 --link 就可以解决网络问题
[root@CZP ~]# docker exec -it tomcat03 ping tomcat02
PING tomcat02 (172.18.0.4) 56(84) bytes of data.
64 bytes from tomcat02 (172.18.0.4): icmp_seq=1 ttl=64 time=0.128 ms
64 bytes from tomcat02 (172.18.0.4): icmp_seq=2 ttl=64 time=0.097 ms
64 bytes from tomcat02 (172.18.0.4): icmp_seq=3 ttl=64 time=0.091 ms
64 bytes from tomcat02 (172.18.0.4): icmp_seq=4 ttl=64 time=0.109 ms
64 bytes from tomcat02 (172.18.0.4): icmp_seq=5 ttl=64 time=0.097 ms
64 bytes from tomcat02 (172.18.0.4): icmp_seq=6 ttl=64 time=0.096 ms
64 bytes from tomcat02 (172.18.0.4): icmp_seq=7 ttl=64 time=0.092 ms
64 bytes from tomcat02 (172.18.0.4): icmp_seq=8 ttl=64 time=0.094 ms
64 bytes from tomcat02 (172.18.0.4): icmp_seq=9 ttl=64 time=0.102 ms
^C
--- tomcat02 ping statistics ---
9 packets transmitted, 9 received, 0% packet loss, time 1007ms
rtt min/avg/max/mdev = 0.091/0.100/0.128/0.015 ms


# 反向是否可以ping通吗
[root@CZP ~]# docker exec -it tomcat02 ping tomcat03
```

```bash
/etc/hosts  配置端口和域名的绑定
```

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619185017414.png)

本地探究 – link 就是我们在host配置中增加了一个172.18.0.3 tomcat02 312857784cd4

我们现在玩Docker已经不建议使用–link了!

自定义网络,不使用docker0!

docker0问题: 它不支持容器名连接访问!

## 自定义网络

> 查看所有的docker网络

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200619185041987.png#pic_center)

**网络模式**

bridge : 桥接 docker 大桥

none: 不配置网络

host: 和宿主机共享网络

container: 容器内网络联通!

**测试**

```bash
# 直接启动的命令 --net brodge,默认docker0
docker run -d -P --name tomcat01 --net bridge tomcat

# docker0的特点: 默认的,域名是不能访问的, --link可以打通连接

# 自定义

[root@CZP ~]# docker network create --help

Usage:	docker network create [OPTIONS] NETWORK

Create a network

Options:
      --attachable           Enable manual container attachment
      --aux-address map      Auxiliary IPv4 or IPv6 addresses used by Network driver (default map[])
      --config-from string   The network from which copying the configuration
      --config-only          Create a configuration only network
  -d, --driver string        Driver to manage the Network (default "bridge")
      --gateway strings      IPv4 or IPv6 Gateway for the master subnet
      --ingress              Create swarm routing-mesh network
      --internal             Restrict external access to the network
      --ip-range strings     Allocate container ip from a sub-range
      --ipam-driver string   IP Address Management Driver (default "default")
      --ipam-opt map         Set IPAM driver specific options (default map[])
      --ipv6                 Enable IPv6 networking
      --label list           Set metadata on a network
  -o, --opt map              Set driver specific options (default map[])
      --scope string         Control the network's scope
      --subnet strings       Subnet in CIDR format that represents a network segment

[root@CZP ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet
677fae13a48c634dc03c56641b9ba31354846d31a196fdcb92c9ef6ddff73150
[root@CZP ~]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
228826a97a0b        bridge              bridge              local
c3b4884cd4db        host                host                local
677fae13a48c        mynet               bridge              local
35885200f93d        none                null                local
```

我们自己的网络就创建好了

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619185056508.png)

```bash
[root@CZP ~]#  docker run -d -P --name tomcat-net-01 --net mynet tomcat:9.0
336dd072ca17ac1adf514c44c8dcbd3358146d6d60667f3a0f99dbbb3e305f09
[root@CZP ~]#  docker run -d -P --name tomcat-net-02 --net mynet tomcat:9.0
2cea3bb29350ae99ce26c1bf6f8d1f2dcfb25bf8042193263ce275308e9eb42d
[root@CZP ~]# docker network inspect mynet
[
   {
       "Name": "mynet",
       "Id": "677fae13a48c634dc03c56641b9ba31354846d31a196fdcb92c9ef6ddff73150",
       "Created": "2020-06-14T16:49:14.554786193+08:00",
       "Scope": "local",
       "Driver": "bridge",
       "EnableIPv6": false,
       "IPAM": {
           "Driver": "default",
           "Options": {},
           "Config": [
               {
                   "Subnet": "192.168.0.0/16",
                   "Gateway": "192.168.0.1"
               }
           ]
       },
       "Internal": false,
       "Attachable": false,
       "Ingress": false,
       "ConfigFrom": {
           "Network": ""
       },
       "ConfigOnly": false,
       "Containers": {
           "2cea3bb29350ae99ce26c1bf6f8d1f2dcfb25bf8042193263ce275308e9eb42d": {
               "Name": "tomcat-net-02",
               "EndpointID": "ebff8e9ef22bd3d66d0de4229d1f3a3c610785b23005294f60f96f3089d52c3d",
               "MacAddress": "02:42:c0:a8:00:03",
               "IPv4Address": "192.168.0.3/16",
               "IPv6Address": ""
           },
           "336dd072ca17ac1adf514c44c8dcbd3358146d6d60667f3a0f99dbbb3e305f09": {
               "Name": "tomcat-net-01",
               "EndpointID": "69451bb0c95ed27d207cd2bade9c57fd2625c245b8b8cb3e5d0dea530a368683",
               "MacAddress": "02:42:c0:a8:00:02",
               "IPv4Address": "192.168.0.2/16",
               "IPv6Address": ""
           }
       },
       "Options": {},
       "Labels": {}
   }
]
```

现在不使用–link也可以ping名字了,推荐使用这种网络

```bash
[root@CZP ~]# docker exec tomcat-net-01 ping tomcat-net-02
PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data.
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.080 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.096 ms
64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.086 ms
^C
[root@CZP ~]# 
```

好处:

不同的集群使用不同的集群,保证集群之间是安全和健康的

## 网络联通

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619185116312.png)

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619185116312.png)

```bash
#测试打通 tomcat01到tomcat-net-01
# 连通之后就是将 tomcat01 放到了mynet网络下
# 一个容器两个ip   阿里云: 公网ip 私网ip
```

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619185223260.png)

这样容器之间就可以ping通了

## 实战 redis集群部署

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619185253550.png)

```bash
# 创建网卡
docker network create --subnet 172.38.0.0/16 redis

# 通过脚本创建六个redis配置
for port in $(seq 1 6);\
do \
mkdir -p /mydata/redis/node-${port}/conf
touch /mydata/redis/node-${port}/conf/redis.conf
cat << EOF >> /mydata/redis/node-${port}/conf/redis.conf
port 6379
bind 0.0.0.0
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
cluster-announce-ip 172.38.0.1${port}
cluster-announce-port 6379
cluster-announce-bus-port 16379
appendonly yes
EOF
done



# 通过脚本运行六个redis
for port in $(seq 1 6);\
do \
docker run -p 637${port}:6379 -p 1637${port}:16379 --name redis-${port} \
-v /mydata/redis/node-${port}/data:/data \
-v /mydata/redis/node-${port}/conf/redis.conf:/etc/redis/redis.conf \
-d --net redis --ip 172.38.0.1${port} redis:5.0.9-alpine3.11 redis-server /etc/redis/redis.conf 
done

#停止redis并删除容器
for port in $(seq 1 6);\
do \
docker stop redis-${port}; \
docker rm redis-${port};
done

docker exec -it redis-1 /bin/sh #redis默认没有bash
redis-cli --cluster create 172.38.0.11:6379 172.38.0.12:6379 172.38.0.13:6379 172.38.0.14:6379 172.38.0.15:6379 172.38.0.16:6379  --cluster-replicas 1
```

集群搭建成功

![在这里插入图片描述](28.Docker%E5%9F%BA%E7%A1%80.assets/20200619185407282.png)

# SpringBoot微服务打包Docker镜像

1. 构建springBoot项目
2. 打包应用 (使用maven打包，点击maven中的packge)
3. 编写dockerfile

![image-20211006144539659](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211006144539659.png)

4. 构建镜像

![image-20211006144735485](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211006144735485.png)

上传jar包和dockerfile到docker中的idea文件夹中。

![image-20211006144849195](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211006144849195.png)

构建镜像。

5. 发布运行

![image-20211006145011867](28.Docker%E5%9F%BA%E7%A1%80.assets/image-20211006145011867.png)

