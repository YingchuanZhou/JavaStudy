# 	MyBatis
* 环境：
	* JDK 1.8
	* MySQL 5.7
	* Maven 3.6.1
* 回顾：
	* JDBC
	* MySQL
	* Java基础
	* Maven
	* Junit
SSM框架：配置文件的，最好的方式：看官网文档。
## 简介
###  什么是Mybatis
* MyBatis 是一款优秀的持久层框架;
* 它支持自定义 SQL、存储过程以及高级映射。
* MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。
* MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。
* MyBatis本是apache的一个开源项目，iBatis，2010年这个项目由apache迁移到了google并且更名为MyBatis
* 2013年11月迁移到了GitHub
### 如何获得MyBatis？
* maven仓库
* GitHub：
* 中文文档：https://mybatis.org/mybatis-3/zh/index.html
###  持久化
数据持久化

* 持久化就是将程序的数据在持久状态和瞬时状态转化的过程
* 内存：**断电即失**
* 数据库（Jdbc）,io文件持久化。
* 生活：冷藏，罐头
为什么要持久化？

	* 有一些对象，不能让他丢掉
	* 内存太贵
###  持久层
Dao层、Service层、Controller层
* 完成持久化工作的代码块
* 层界限十分明显
### 为什么需要MyBatis
* 帮助程序员将数据存入到数据库中
* 方便
* 传统的JDBC代码太复杂了，简化，框架，自动化
* 不用MyBatis也可以，** 技术没有高低之分**
* 优点：
	* 简单易学
	* 灵活
	* sql和代码的分离，提高了可维护性。
	* 提供映射标签，支持对象与数据库的orm字段关系映射
	* 提供对象关系映射标签，支持对象关系组建维护
	* 提供xml标签，支持编写动态sql
**最重要的是：用的人多！**
## 第一个MyBatis程序
思路：搭建环境 --> 导入MyBatis --> 编写代码 -->测试
### 环境搭建
1. 建立数据库
2. 创建一个普通的Maven项目
3. 删除src目录
4. 导入maven依赖
### 创建一个子项目
1. 编写核心配置文件
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/commodity?useSSL = true &amp;useUnicode=true&amp;characterEncoding=UTF-8"/>
                <property name="username" value="root"/>
                <property name="password" value="zyc766623393"/>
            </dataSource>
        </environment>
    </environments>
    <mappers>
        <mapper resource="org/mybatis/example/BlogMapper.xml"/>
    </mappers>
</configuration>
```
2. 编写MyBatis工具类
```java
package utils;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

//SqlSessionFactory -->sqlSession
public class MyBatisUtil {

    public static SqlSessionFactory sqlSessionFactory=null;
    static {
//        使用mybatis第一步获取SqlSessionFactory对象
        String resource = "mybatis-config.xml";
        try {
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。
    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。
    public static SqlSession getSqlSession(){
        SqlSession sqlSession = sqlSessionFactory.openSession();
        return sqlSession;
    }
}

```
### 编写代码
* 实体类
```java
package pojo;

public class User {
    private String username;
    private String password;
    private String customer_no;

    public User() {
    }

    public User(String username, String password, String customer_no) {
        this.username = username;
        this.password = password;
        this.customer_no = customer_no;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getCustomer_no() {
        return customer_no;
    }

    public void setCustomer_no(String customer_no) {
        this.customer_no = customer_no;
    }

    @Override
    public String toString() {
        return "User{" +
                "username='" + username + '\'' +
                ", password='" + password + '\'' +
                ", customer_no='" + customer_no + '\'' +
                '}';
    }
}

```
* Dao接口
```java
package dao;

import pojo.User;

import java.util.List;

public interface UserDao {
    public List<User> getUserList();
}

```
* 接口实现类(以前的)
```java
package dao.impl;

import dao.UserDao;
import pojo.User;

import java.util.List;

public class UserDaoImpl implements UserDao {

    public List<User> getUserList() {
//        执行sql
//        使用JDBC
//        返回获取的对象
        return null;
    }
}

```
** 现在的：**将原来的接口实现类换成了现在的Mapper配置文件
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--namespace 绑定对应Dao层的Mapper接口-->
<mapper namespace="dao.UserDao">
<!--    select查询语句，这里的id就是Dao层中的接口，相当于实现接口-->
    <select id="getUserList" resultType="pojo.User">
        select * from user ;
    </select>
</mapper>
```
### 使用Junit测试
** 注意：org.apache.ibatis.binding.BindingException: Type interface dao.UserDao is not known to the MapperRegistry.** 
需要在mybatis-config.xml中注册mapper
```xml
<!--每一个mapper都需要在这里面注册-->
    <mappers>
        <mapper resource="dao.UserDao"></mapper>
    </mappers>
```

** 注意：java.lang.ExceptionInInitializerError
at dao.UserDaoTest.test(UserDaoTest.java:16) **
这里是因为Maven过滤问题，Maven约定大于配置，导致Maven资源导出失败，Maven约定只会导出resources中的资源文件，而我们的mapper.xml放在java文件夹下的。
在pom.xml中添加配置
```xml
<!--    解决Maven资源文件导出失败-->
    <build>
        <resources>
            <resource>
                <directory>src/main/resources</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
            </resource>
            <resource>
                <directory>src/main/java</directory>
                <includes>
                    <include>**/*.properties</include>
                    <include>**/*.xml</include>
                </includes>
                <filtering>true</filtering>
            </resource>
        </resources>
    </build>
```
Junit测试：
```java

package dao;

import org.apache.ibatis.session.SqlSession;
import org.junit.Test;
import pojo.User;
import utils.MyBatisUtil;

import java.util.List;

public class UserDaoTest {

    @Test
    public void test(){

        //1.获取sqlSession对象
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        //2.执行sql,方式1：getMapper
        UserDao userDao = sqlSession.getMapper(UserDao.class);
        List<User> userList = userDao.getUserList();

        //方式2：
        List<User> users = sqlSession.selectList("dao.UserDao.getUserList");

        for (User user : userList) {
            System.out.println(user);
        }
        //关闭sqlSession
        sqlSession.close();
        //

    }
}

```
## CRUD
### namespace
namespace 中的包名要和Dao/Mapper中的接口包名一致
### select
选择查询语句
	* id：就是对应的namespace中的方法名
	* resultType：sql语句执行的返回值
	* parameterType：参数类型
1. 编写接口
```java
User getUserById(String username);
```
2. 编写mapper.xml
```xml
 <select id="getUserById" parameterType="String" resultType="pojo.User">
        select * from commodity.user where username = #{username}
    </select>
```
3. 编写Junit测试
```java
@Test
    public void test2(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        UserDao mapper = sqlSession.getMapper(UserDao.class);
        User userById = mapper.getUserById("766623393");
        System.out.println(userById);
        sqlSession.close();
    }
```
### insert
```xml
    <insert id="addUser" parameterType="pojo.User">
        insert into commodity.user (username , password, customer_no) values (#{username},#{password},#{customer_no})
    </insert>
```
### update
```xml
   <update id="updateUser" parameterType="pojo.User">
        update commodity.user set username=#{username},password = #{password},customer_no=#{customer_no} where username = #{username}
    </update>
```
### delete
```xml
<delete id="deleteUser" parameterType="String">
        delete from commodity.user where username = #{username}
    </delete>
```
 **注意：增删改必须提交事务**

### 常见问题
1. 标签一定要对应

2. 在MyBatis核心配置文件中注册Mapper.xml文件时需要在resource属性中写出xml文件的详细路径
    ```dao/UserMapper.xml```

3. 程序配置文件必须符合规范

4. NullPointerExcepption：空指针异常，没有注册到资源

5. 输出的xml文件出现乱码问题（有待解决）

   https://blog.csdn.net/weixin_49702090/article/details/108153030?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.control&spm=1001.2101.3001.4242

6. maven资源不能导出问题 
### 万能Map
假设我们实体类或者数据库表中字段或者参数过多(多条件查询），我们应该考虑使用Map
Mapper接口：
```int addUser2(Map<String,Object> map);```
Mapper.xml：
```xml
<!--    这种方式后面取的值只需要与map中的键对应，不需要与数据库和实例中的属性对应
        传递map的key
-->
    <insert id="addUser2" parameterType="map">
        insert into commodity.user (username,password,customer_no) values (#{userName},#{PassWord},#{customerNo})
    </insert>
```
Junit测试：
```java
    @Test
    public void addUser2(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        UserDao mapper = sqlSession.getMapper(UserDao.class);
        Map<String, Object> map = new HashMap<>();
        map.put("userName","ZengJing");
        map.put("PassWord","123456");
        map.put("customerNo","766623393");
        int i = mapper.addUser2(map);
        if (i>0)
            System.out.println("111");
        sqlSession.commit();
        sqlSession.close();
    }

```

**Map传递参数，直接在sql中取出key即可**【parameterType="map"】
**对象传递参数，直接在sql中取出对象的属性即可**【parameterType="Object·"】
**只有一个基本数据类型参数的情况下，直接在sql中取到**【parameterType="基本数据类型"】或者不写

### 模糊查询

```List<User> getUserByLike(String value);```

Mapper.xml

```xml
<!--    模糊查询-->
    <select id="getUserByLike" parameterType="String" resultType="pojo.User">
        select * from commodity.user where username like #{value}
    </select>
```

```java
@Test
    public void test3(){
        //1.获取sqlSession对象
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        //2.执行sql,方式1：getMapper
        UserDao userDao = sqlSession.getMapper(UserDao.class);

        List<User> userList = userDao.getUserByLike("Z%");
        for (User user : userList) {
            System.out.println(user);
        }
        //关闭sqlSession
        sqlSession.close();
        //
    }
```

1. Java代码执行的时候传入通配符%

2. 在sql拼接中使用通配符！（有可能发生sql注入）

   ```xml
   <!--    模糊查询-->
       <select id="getUserByLike" parameterType="String" resultType="pojo.User">
           select * from commodity.user where username like "%"#{value}"%"
       </select>
   ```

## 配置解析

### 核心 配置文件

* mybatis-config.xml
* MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。
* configuration（配置）
  - [properties（属性）](https://mybatis.org/mybatis-3/zh/configuration.html#properties)
  - [settings（设置）](https://mybatis.org/mybatis-3/zh/configuration.html#settings)
  - [typeAliases（类型别名）](https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases)
  - [typeHandlers（类型处理器）](https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers)
  - [objectFactory（对象工厂）](https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory)
  - [plugins（插件）](https://mybatis.org/mybatis-3/zh/configuration.html#plugins)
  - environments（环境配置）
    - environment（环境变量）
      - transactionManager（事务管理器）
      - dataSource（数据源）
  - [databaseIdProvider（数据库厂商标识）](https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider)
  - [mappers（映射器）](https://mybatis.org/mybatis-3/zh/configuration.html#mappers)

### 环境配置（environments）

MyBatis可以配置成适应多环境

**不过要记住：尽管可以配置多个环境，但每个SqlSessionFactory实例只能选择一种环境。**

学会使用多套运行环境。

MyBatis默认的事务管理器就是JDBC，连接池是POOLED

### 属性（properties）

编写一个配置文件

db.properties

```properties
driver = com.mysql.cj.jdbc.Driver
url = jdbc:mysql://localhost:3306/commodity?useSSL=true&useUnicode=true&characterEncoding=utf-8
username = root
password = zyc766623393
```

在核心配置文件中引入外部文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!--核心配置文件-->
<configuration>
<!--    引入外部文件-->
    <properties resource="db.properties">
<!--        可以将用户名和密码卸载标签中-->
    </properties>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${driver}"/>
                <property name="url" value="${url}"/>
                <property name="username" value="${username}"/>
                <property name="password" value="${password}"/>
            </dataSource>
        </environment>
    </environments>
<!--    每个mapper都需要注册-->
    <mappers>
        <mapper resource="mapper/UserMapper.xml"></mapper>
    </mappers>
</configuration>
```

* 可以直接引入外部文件
* 可以在其中增加一些配置
* 如果两个文件中有相同的属性，优先外部配置文件



### 类型别名(typeAliases)

* 类型别名为Java类型设置一个短名字

* 存在的意义仅用来减少类完全限定名的冗余

  在核心配置文件中添加
  
  ```xml
  <!--    给类取别名-->
      <typeAliases>
          <typeAlias type="pojo.User" alias="User"/>
      </typeAliases>
  
  ```
  
  使用：
  
  ```mxl
      <select id="getUserList" resultType="User">
          select * from commodity.user ;
      </select>
  
  ```
  
  
  
  或者：也可以指定一个包名，MyBatis会自动在报名下面搜索JavaBean，扫描实体类的包，默认的别名就是类名，手写字母小写。
  
  ```xml
  <!--    给类取别名-->
      <typeAliases>
  <!--        <typeAlias type="pojo.User" alias="User"/>-->
          <package name="pojo"/>
      </typeAliases>
  
  ```
  
  使用：
  
  ```xml
      <select id="getUserList" resultType="user">
          select * from commodity.user ;
      </select>
  ```
  
  此外：这种方式不支持自定义别名，如果要自定义别名，需要自己给实体类上加注解，通过注解的方式，直接给实体类自定义命名。
  
  ```java
  @Alias("user")
  public class User {
      private String username;
      private String password;
      private String customer_no;
  ```
  
  使用：
  
  ```xml
      <select id="getUserList" resultType="user">
          select * from commodity.user ;
      </select>
  
  ```
  
  注意：
  
  * 在实体类较少的时候建议使用第一种方式
  
  * 如果实体类较多，使用第二种方式
  
  * 第一种可以自定义（DIY）别名，第二种不可以。如果非要改，需要给实体类加注解。
  
    ### 设置（setting）
  
    这是Mybatis中极为重要的调整设置，他会改变MyBatis运行时的行为。
  
    | cacheEnabled       | 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。     | true \| false | true  |
    | ------------------ | ------------------------------------------------------------ | ------------- | ----- |
    | lazyLoadingEnabled | 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 `fetchType` 属性来覆盖该项的开关状态。 | true \| false | false |

| mapUnderscoreToCamelCase | 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 | true \| false | False |
| ------------------------ | ------------------------------------------------------------ | ------------- | ----- |
|                          |                                                              |               |       |

| logImpl | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 | SLF4J \| LOG4J \| LOG4J2 \| JDK_LOGGING \| COMMONS_LOGGING \| STDOUT_LOGGING \| NO_LOGGING | 未设置 |
| ------- | ----------------------------------------------------- | ------------------------------------------------------------ | ------ |
|         |                                                       |                                                              |        |

具体设置见文档。

### 其他配置

- [typeHandlers（类型处理器）](https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers)
- [objectFactory（对象工厂）](https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory)
- [plugins（插件）](https://mybatis.org/mybatis-3/zh/configuration.html#plugins)
  * mybatis-generator-core 自动生成mybatis代码的插件
  * mybatis-plus 与MyBatis互补的插件，mybatis的增强工具
  * 通用mapper

### 映射器（mappers）

MapperRegistry：注册绑定mapper.xml文件

方式一：

```xml
<!-- 使用相对于类路径的资源引用 -->
    <mappers>
        <mapper resource="mapper/UserMapper.xml"/>
    </mappers>
```

方式二：使用class属性绑定注册

```xml
   <!-- 使用映射器接口实现类的完全限定类名 -->
	<mappers>
        <mapper class="mapper.UserMapper"/>
    </mappers>
```

**注意点**

* 接口和他的mapper配置文件必须同名
* 接口和他的mapper配置文件必须在同一个包下

方式三：使用扫描包进行注入绑定

```xml
   <!-- 将包内的映射器接口实现全部注册为映射器 -->
	<mappers>
        <package name="mapper"/>
    </mappers>
```

**注意点**

* 接口和他的mapper配置文件必须同名
* 接口和他的mapper配置文件必须在同一个包下

### 生命周期

生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题

**SqlSessionFactoryBuilder**

* 一旦创建了SqlSessionFactory之后，就不需要再使用他了

* 局部变量

  

**SqlSessionFactory**

* 说白了就可以想象为：数据库连接池
* SqlSessionFactory一旦被创建就应该在应用的运行期间一直存在，**没有任何理由丢弃它或者重新创建另外一个实例**
* 因此SqlSessionFactory的最佳作用域就是应用作用域
* 最简单的就是使用**单例模式**或者静态单例模式



**SqlSession**

* 连接到连接池的一个请求
* SqlSession的实例不是线程安全的，因此不能被共享，所以他的最佳作用域是请求或者方法作用域。
* 用完之后需要赶紧关闭，否则会造成资源浪费
* 每一个SqlSession可以获取多个Mapper，每个Mapper就是一个业务

## 结果集映射（ResultMap）

**解决实体类的属性名和数据库字段名不一致问题**

```
数据库：id name pwd
实体类：id name password
```



解决方法：

* 取别名，将sql语句中要查询数据库的字段名称取一个别名（as），这别名与属性名称相同

```xml
<!--    取别名方式-->
    <select id="getUserById" parameterType="int">
        select id, name,pwd as password from commodity.user where id = #{id}
    </select>
```

* 结果集映射

```xml
    <!--    结果集映射方式-->

    <resultMap id="UserMap" type="User">
        <!--    column 是数据库中的字段，property是实体类中的属性-->
        <result column="id" property="id"></result>
        <result column="name" property="name"></result>
        <result column="pwd" property="password"></result>
    </resultMap>

    <select id="getUserById" resultMap="UserMap">
        select * from commodity.user where id = #{id}
    </select>
```

* resultMap元素是MyBatis中最重要最强大的元素
* ResultMap的设计思想是，对于简单的语句根本不需要配置显示的结果集映射，而对于复杂的语句，只需要描述他们的关系就行了。
* ResultMap最优秀的地方在于，虽然你已经对他相当了解了，但是根本就不需要显示的用到他们
* 如果世界总是这么简单就好了（多表查询后续）



## 日志

### 日志工厂

如果一个数据库操作，出现了异常，我们需要排错，日志就是最好的助手。

曾经：sout、debug

现在：日志工厂

| logImpl | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 | SLF4J \| LOG4J \| LOG4J2 \| JDK_LOGGING \| COMMONS_LOGGING \| STDOUT_LOGGING \| NO_LOGGING | 未设置 |
| ------- | ----------------------------------------------------- | ------------------------------------------------------------ | ------ |
|         |                                                       |                                                              |        |

* SLF4J
* LOG4J          【掌握】
* LOG4J2
* JDK_LOGGING
* COMMONS_LOGGING
* STDOUT_LOGGING 【掌握】
* NO_LOGGING

在MyBatis中具体使用哪个日志实现，在设置中设定。

### 标准日志工厂实现

在MyBatis核心配置文件中配置

```xml
<!--    配置输出日志-->
    <settings>
        <setting name="logImpl" value="STDOUT_LOGGING"/>
    </settings>
```

```tex
Checking to see if class pojo.User matches criteria [is assignable to Object]
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
PooledDataSource forcefully closed/removed all connections.
Opening JDBC Connection
Created connection 636782475.
Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@25f4878b]
==>  Preparing: select * from commodity.user ;
==> Parameters: 
<==    Columns: username, password, customer_no
<==        Row: ZengJing, 123456, 766623393
<==        Row: zhouying, 123456, 766623393
<==        Row: zhouyingchuan, 123456, 766623393
<==        Row: zyc, 123, 766623393
<==      Total: 4
User{username='ZengJing', password='123456', customer_no='766623393'}
User{username='zhouying', password='123456', customer_no='766623393'}
User{username='zhouyingchuan', password='123456', customer_no='766623393'}
User{username='zyc', password='123', customer_no='766623393'}
Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@25f4878b]
Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@25f4878b]
Returned connection 636782475 to pool.
```



### Log4j

什么是Log4j？

* Log4j是[Apache](https://baike.baidu.com/item/Apache/8512995)的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是[控制台](https://baike.baidu.com/item/控制台/2438626)、文件、[GUI](https://baike.baidu.com/item/GUI)组件，甚至是套接口服务器、[NT](https://baike.baidu.com/item/NT/3443842)的事件记录器、[UNIX](https://baike.baidu.com/item/UNIX) [Syslog](https://baike.baidu.com/item/Syslog)[守护进程](https://baike.baidu.com/item/守护进程/966835)等
* 可以控制每一条日志的输出格式
* 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程
* 可以通过一个[配置文件](https://baike.baidu.com/item/配置文件/286550)来灵活地进行配置，而不需要修改应用的代码



使用步骤：

	1. maven导入Log4j的包

```xml
<!-- https://mvnrepository.com/artifact/log4j/log4j -->
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>

```

2. log4j.properties配置文件

```properties
#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n
#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/zyc.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n
#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sq1.PreparedStatement=DEBUG

```

3. 配置使用Log4j

```xml
<!--    配置输出日志-->
    <settings>
        <setting name="logImpl" value="LOG4J"/>
    </settings>
```

### 简单使用

1. 在使用Log4j的类中，导入包	import org.apache.log4j.Logger;
2. 日志对象，参数为当前类的class,提升作用域为整个类

```java 
static Logger logger = Logger.getLogger(UserMapperTest.class);
```

3. 日志级别

```java
    @Test
    public void testLog4j(){
        logger.info("info:进入了testLog4j");
        logger.debug("debug:进入了testLog4j");
        logger.error("error:进入了testLog4j");
    }
```

## 分页

为什么要分页？

* 减少数据的处理量

### limit分页：

```sql
select * from table limit startIndex,pageSize;
select * from user limit 1,3; -->[1,4]
select * from user limit 3;-->[0,3]
```

使用MyBatis分页，核心是SQL

1. 接口

```java
List<User> getUserByLimit(Map<String,Integer> map);
```

2. Mapper.xml

```xml
<select id="getUserByLimit" parameterType="map" resultType="User">
        select * from  commodity.user limit #{startIndex},#{pageSize}
</select>
```



3. 测试

```java
   @Test
    public void testLimit(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        HashMap<String, Integer> map = new HashMap<>();
        map.put("startIndex",0);
        map.put("pageSize",2);
        List<User> userByLimit = mapper.getUserByLimit(map);
        for (User user : userByLimit) {
            System.out.println(user);
        }
        sqlSession.close();
    }
```

### RowBounds分页

不适用SQL就可以实现分页

1. 接口

   ```java
   List<User> getUserByRowBounds();
   ```

   

2. mapper.xml

   ```xml
   <select id="getUserByRowBounds" resultType="User">
           select * from  commodity.user
   </select>
   ```

   

3. 测试

   ```java
    @Test
       public void testRowBounds(){
           SqlSession sqlSession = MyBatisUtil.getSqlSession();
           RowBounds rowBounds = new RowBounds(0,2);
        //注意这里的字符串必须精确到接口中的方法名称   
           List<User> users = sqlSession.selectList("mapper.UserMapper.getUserByRowBounds", null, rowBounds);
           for (User user : users) {
               System.out.println(user);
           }
           sqlSession.close();
       }
   ```

### 分页插件

* MyBatis PageHelper 分页插件

  https://pagehelper.github.io/docs/howtouse/

* 一般较小的项目一般不用

## 使用注解开发

### 面向接口编程

系统设计规范应是所有的定义与实现分离

* .关于接口的理解

  * 接口从更深层次的理解，应是定义（规范，约束）与实现（名实分离的原则）的分离。

  * 接口的本身反映了系统设计人员对系统的抽象理解。

  * 接口应有两类：第一类是对一个个体的抽象，它可对应为一个抽象体(abstract class)；

  * 第二类是对一个个体某一方面的抽象，即形成一个抽象面（interface）；

  * 一个体有可能有多个抽象面。

  * 抽象体与抽象面是有区别的。

## 注解开发

1. 注解在接口上实现

   ````java
   @Select("select * from commodity.user")
       List<User> getUserList();
   ````

2. 需要再核心配置文件中绑定接口

   ```xml
   <!--    绑定接口-->
       <mappers>
           <mapper class="mapper.UserMapper"/>
       </mappers>
   ```

   

3. 测试

   ```java
       @Test
       public void test(){
           SqlSession sqlSession = MyBatisUtil.getSqlSession();
   //        底层主要使用反射
           UserMapper mapper = sqlSession.getMapper(UserMapper.class);
           List<User> userList = mapper.getUserList();
           for (User user : userList) {
               System.out.println(user);
           }
           sqlSession.close();
       }
   ```

   

   **注解的本质就是反射**

   **底层：动态代理**



**MyBatis详细的执行流程！**



### 注解实现CURD

可以在MyBatis工具包中设置自动提交事务，但是一般不这样做

```java
  //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。
    // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。
    public static SqlSession getSqlSession(){
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
        return sqlSession;
    }
```



CURD:

```java
public interface UserMapper {

    @Select("select * from commodity.user")
    List<User> getUserList();

    //方法存在多个参数的时候，每个参数前面都应该加上@Param注解
    @Select("select * from user where id = #{uid")
    User getUserById(@Param("uid") int id);

    @Insert("insert into user (id,name,password) values (#{id},#{name},#{password})")
    int addUser(User user);

    @Update("update user set name = #{name},password = #{password} where id = #{id}")
    int updateUser(User user);

    @Delete("delete from user where id = #{uid")
    int deleteUser(@Param("uid") int id);
}

```

```java
    @Test
    public void testSelect(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        User userById = mapper.getUserById(1);
        System.out.println(userById);
        sqlSession.commit();
        sqlSession.close();
    }

    @Test
    public void testInsert(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        int i = mapper.addUser(new User(1, "zyc", "123456"));
        if(i>0)
            sqlSession.commit();
        sqlSession.close();
    }

    @Test
    public void testUpdate(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        int i = mapper.updateUser(new User(1, "zyc", "123456"));
        if(i>0)
            sqlSession.commit();
        sqlSession.close();
    }

    @Test
    public void testDelete(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        int i = mapper.deleteUser(1);
        if(i>0)
            sqlSession.commit();
        sqlSession.close();
    }
```

**注意：1. 在多个参数的时候，每个参数前面都应该加上@Param注解												 2. 必须要现在MyBatis核心文件中注册绑定接口**

```xml
<!--    绑定接口-->
    <mappers>
        <mapper class="mapper.UserMapper"/>
    </mappers>
```



**关于@Param()注解**

* 基本类型的参数或者String类型的参数，需要加上
* 引用类型不需要加
* 如果只有一个基本类型的参数，可以忽略，但是建议加上
* 我们在SQL中引用的就是我们@Param("")中的属性名称

**#{}和${}的区别**

1. a、#{}是预编译处理，${}是字符串替换。

   b、Mybatis 在处理#{}时，会将 sql 中的#{}替换为?号，调用 PreparedStatement 的 set 方法来赋值；
   c、Mybatis 在处理${}时，就是把${}替换成变量的值。

   d、使用#{}可以有效的防止 SQL 注入，提高系统安全性。

3. #方式能够很大程度防止sql注入。

4. $方式无法防止Sql注入。

5. $方式一般用于传入数据库对象，例如传入表名.
6. 一般能用#的就别用$.

MyBatis排序时使用order by 动态参数时需要注意，用$而不是#

## Lombok

* Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.
* Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.

使用步骤：

1. 在IDEA中安装Lombok插件
2. 在项目中导入Lombok的jar包

```xml
  <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.20</version>
<!--            <scope>provided</scope>-->
        </dependency>

```



```java
@Getter and @Setter
@FieldNameConstants
@ToString
@EqualsAndHashCode
@AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor
@Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog
@Data
@Builder
@SuperBuilder
@Singular
@Delegate
@Value
@Accessors
@Wither
@With
@SneakyThrows
@val
@var
experimental @var
@UtilityClass
```

说明：

```java
@Data：无参构造、get、set、toString、hashcode、equals
@ToString   toString方法
@EqualsAndHashCode		equals和hashcode方法
@AllArgsConstructor		有参构造
@NoArgsConstructor		无参构造
@Setter 	set方法
@Getter     get方法
```

## 多对一查询

### 环境搭建

1. 导入Lombok
2. 新建实体类
3. 建立Mapper接口
4. 建立Mapper.xml文件
5. 在核心配置文件中注册Mapper接口或者文件
6. 测试查询是否能够成功

### 按照查询嵌套处理

一个学生对应多个老师的查询：

Mapper.xml文件：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="mapper.StudentMapper">

<!--
    多表查询：
        多个学生对应一个老师
    思路：
        1. 查询所有的学生
        2. 根据学生查询出来的tid，寻找对应的老师
-->
    <select id="getStudents" resultMap="StudentTeacher">
        select * from student
    </select>

    <resultMap id="StudentTeacher" type="Student">
        <result column="name" property="name"/>
        <result column="id" property="id"/>
<!--
        复杂属性需要单独处理
            对象：association
            集合：collection
-->
        <association column="tid" property="teacher" javaType="Teacher" select="getTeachers"/>
        <!--        这个select相当于嵌套查询-->
    </resultMap>
    
    <select id="getTeachers" resultType="Teacher">
        select * from teacher where id = #{tid}
    </select>
</mapper>
```

StudentMapper接口:

```java
public interface StudentMapper {

    List<Student> getStudents();
}
```

```java
 @Test
    public void test(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
        List<Student> students = mapper.getStudents();
        for (Student student : students) {
            System.out.println(student);
        }
        sqlSession.close(); 
    }
```

学生实体类的定义：

```java
@Data
public class Student {
    private String name;
    private String id;
    private int tid;
    private Teacher teacher;
}
```

老师实体类

```java
@Data
public class Teacher {
    private int id;
    private String name;
}

```

### 按照结果嵌套处理

学生实体类：

```java
@Data
public class Student {
    private String name;
    private String id;
    private int tid;
    private Teacher teacher;
}
```

老师实体类：

```java
@Data
public class Teacher {
    private int id;
    private String name;
}
```

StudentMapper接口：

```java
public interface StudentMapper {

    List<Student> getStudents2();
}
```

Mapper.xml文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="mapper.StudentMapper">
<!--    按照结果嵌套查询-->
    <select id="getStudents2" resultMap="StudentTeacher2">
        select s.id sid,s.name sname, t.name tname
        from student s, teacher t
        where s.tid = t.id
    </select>
    
    <resultMap id="StudentTeacher2" type="Student">
        <result column="sid" property="id"></result>
        <result column="sname" property="name"></result>
<!--        <result column="tid" property="teacher"></result>-->
        <association property="teacher" javaType="Teacher" >
            <result column="tname" property="name"></result>
        </association>
    </resultMap>


</mapper>
```

测试

```java
@Test
    public void test2(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
        List<Student> students = mapper.getStudents2();
        for (Student student : students) {
            System.out.println(student);
        }
        sqlSession.close(); 
    }
```

回顾MySQL多对一查询方式：

* 子查询  	<------按照查询嵌套处理
* 连表查询      <---------按照结果嵌套处理

## 一对多查询

一个老师有多个学生

### 按照查询嵌套处理

实体类

```java
@Data
public class Student {
    private String name;
    private String id;
    private int tid;
    private Teacher teacher;
}
```

```java
@Data
public class Teacher {
    private int id;
    private String name;

//    定义学生属性
    private List<Student> students;
}

```



Mapper接口

```java
public interface TeacherMapper {

    //查询一个指定老师对应得多个学生
    Teacher getTeacher(@Param("tid") int id);

}

```

Mapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="mapper.TeacherMapper">

<!--    =================================================-->

<!--    按照查询嵌套查询-->
    <select id="getTeacher2" resultMap="TeacherStudent2">
        select * from teacher where id = #{tid}
    </select>

    <resultMap id="TeacherStudent2" type="Teacher">
        <result property="id" column="id"/>
        <result property="name" column="name"/>
<!--        javaType中为实体类中的属性类型     ofType为返回的泛型类型-->
        <collection property="students" javaType="ArrayList" ofType="Student" select="getStudentByTeacherId" column="tid"/>
    </resultMap>

    <select id="getStudentsByTeacherId" resultType="Student">
        select * from student where tid = #{tid}
    </select>
</mapper>
```

测试

```java
@Test
    public void test(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);
        Teacher teacher = mapper.getTeacher(1);
        System.out.println(teacher);
        /*
        Teacher(
        id=1, name=周迎川,
         students=
         [Student(name=陈涵, id=631907060501, tid=1, teacher=null),
         Student(name=王小红, id=631907060434, tid=1, teacher=null),
         Student(name=曾静, id=189510205, tid=1, teacher=null),
         Student(name=曲洪洋, id=631907060520, tid=1, teacher=null),
          Student(name=董不懂, id=631907060305, tid=1, teacher=null)])
         */
        sqlSession.close();
    }
```

### 按照结果嵌套处理

实体类

```java
@Data
public class Student {
    private String name;
    private String id;
    private int tid;
    private Teacher teacher;
}
```

```java
@Data
public class Teacher {
    private int id;
    private String name;

//    定义学生属性
    private List<Student> students;
}

```



Mapper接口

```java
public interface TeacherMapper {

    //查询一个指定老师对应得多个学生
    Teacher getTeacher2(@Param("tid") int id);

}

```

Mapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="mapper.TeacherMapper">


<!--    按照结果嵌套查询-->
    <select id="getTeacher" resultMap="TeacherStudent">
        select t.id tid, t.name tname ,s.id sid, s.name sname
        from student s, teacher t
        where s.tid= t.id and t.id = #{tid}
    </select>

    <resultMap id="TeacherStudent" type="Teacher">
        <result property="id" column="tid"/>
        <result property="name" column="tname"/>
 <!--
        复杂属性需要单独处理
            对象：association
            集合：collection
        javaType=""   指定属性类型
        集合中的泛型信息，我们使用ofType=""获取
-->
        <collection property="students" ofType="Student">
            <result property="id" column="sid"/>
            <result property="name" column="sname"/>
            <result property="tid" column="tid"/>
        </collection>
    </resultMap>

</mapper>
```

测试

```java
 @Test
    public void test2(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        TeacherMapper mapper = sqlSession.getMapper(TeacherMapper.class);
        Teacher teacher = mapper.getTeacher(1);
        System.out.println(teacher);
        /*
        Teacher(
        id=1, name=周迎川,
         students=
         [Student(name=陈涵, id=631907060501, tid=1, teacher=null),
         Student(name=王小红, id=631907060434, tid=1, teacher=null),
         Student(name=曾静, id=189510205, tid=1, teacher=null),
         Student(name=曲洪洋, id=631907060520, tid=1, teacher=null),
          Student(name=董不懂, id=631907060305, tid=1, teacher=null)])
         */
        sqlSession.close();
    }
```

### 小结

1. 关联-association	【多对一】
2. 集合-collection        【一对多】
3. javaType & ofType
   * javaType  用来指定实体类中的属性返回值类型
   * ofType   用来指定映射到List或者集合中的pojo类型，泛型约束类型！

注意点：

* 保证SQL的可读性，尽量保证通俗易懂
* 注意一对多和多对一中属性和字段的问题
* 如果问题不好排查，可以使用日志，建议使用 Log4j

面试高频：

* MySQL引擎
* InnoDB底层原理
* 索引
* 索引优化

## 动态SQL

什么是动态SQL？   动态SQL就是根据不同的条件生成不同的SQL

利用动态SQL可以摆脱拼接SQL的痛苦。

如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。

- if
- choose (when, otherwise)
- trim (where, set)
- foreach

### 搭建环境

创建一个基础工程

1. 导包
2. 编写配置文件
3. 编写实体类

```java
@Data
public class CommoditySupplier {

//    这里的属性名与数据库的字段不一样  supplier_no，
//    这里采用了驼峰命名，后面需要处理才能与数据库字段对应
    private String supplierNo;
    private String supplierName;
    private String linkman;
    private String telNumber;
    private String supplierIntroduce;
}
```



4. 编写实体类对应的Mapper接口及Mapper.xml文件

```java
public interface CommoditySupplierMapper {

//    添加
    int addSupplier(CommoditySupplier commoditySupplier);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="mapper.CommoditySupplierMapper">
    <insert id="addSupplier" parameterType="CommoditySupplier">
        insert into commodity_supplier
        values(#{supplierNo},#{supplierName},#{linkman},#{telNumber},#{supplierIntroduce})
    </insert>
</mapper>
```

测试

```java
public class SupplierTest {

    @Test
    public void testAdd(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        CommoditySupplierMapper mapper = sqlSession.getMapper(CommoditySupplierMapper.class);
        CommoditySupplier commoditySupplier = new CommoditySupplier(IdUtil.getId(),"百度","李彦宏","1111111888","你不知道的这里都有");
        int i = mapper.addSupplier(commoditySupplier);
        System.out.println(i);
        sqlSession.commit();
        sqlSession.close();
    }
```

新建了一个工具类：由于数据库的id自增带来的缺陷，使用UUID类随机生成id

```java
public class IdUtil {

    public static String getId(){
//        数据库主键自增有缺陷，id只能增加，不能生成前面删除的id
//        使用UUID类，实现随机产生个id
        return UUID.randomUUID().toString().replace("-","");
    }

    @Test
    public void test(){
        System.out.println(IdUtil.getId());
    }
}

```

### if标签

接口：

```java
//    使用if语句
    List<CommoditySupplier> querySupplierByIf(Map<String,String> map);
```

Mapper.xml

```xml
<!--    使用if查询-->
    <select id="querySupplierByIf" parameterType="map" resultType="CommoditySupplier">
        select * from commodity_supplier where 1=1
        <if test="supplierNo != null">
            and supplier_no = #{supplierNo}
        </if>
        <if test="supplierName != null">
            and supplier_name = #{supplierName}
        </if>
    </select>
```

测试

```java
 @Test
    public void querySupplierByIf(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        CommoditySupplierMapper mapper = sqlSession.getMapper(CommoditySupplierMapper.class);
        HashMap<String, String> map = new HashMap<>();
        map.put("supplierNo","1111");
        map.put("supplierName","阿里巴巴");
        List<CommoditySupplier> commoditySuppliers = mapper.querySupplierByIf(map);
        for (CommoditySupplier commoditySupplier : commoditySuppliers) {
            System.out.println(commoditySupplier);
        }
        sqlSession.close();
    }
```

### choose (when, otherwise)

* 有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。

接口：

```java
//    使用choose
    List<CommoditySupplier> querySupplierByChoose(Map<String,String> map);
```

Mapper.xml

```xml
<!--   使用choose -->
    <select id="querySupplierByChoose" parameterType="map" resultType="CommoditySupplier">
        select * from commodity_supplier
        <where>
--         where语句会自动去掉多余的and和自己本身
            <choose>
                <when test="supplierNo != null">
                    supplier_no = #{supplierNo}
                </when>
                <when test="supplierName != null">
                    and supplier_name = #{supplierName}
                </when>
                <otherwise>
                    and linkman = #{linkman}
                </otherwise>
            </choose>
        </where>
    </select>
```



测试：

```java
    @Test
    public void querySupplierByChoose(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        CommoditySupplierMapper mapper = sqlSession.getMapper(CommoditySupplierMapper.class);
        HashMap<String, String> map = new HashMap<>();
        map.put("supplierNo","2222");
//        map.put("supplierName","字节跳动");
//        map.put("linkman","王一鸣");
        List<CommoditySupplier> commoditySuppliers = mapper.querySupplierByChoose(map);
        for (CommoditySupplier commoditySupplier : commoditySuppliers) {
            System.out.println(commoditySupplier);
        }
        sqlSession.close();
    }
```





### trim (where, set)

where :

* *where* 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，*where* 元素也会将它们去除。

set:

* *set* 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（这些逗号是在使用条件语句给列赋值时引入的）。

Set测试接口

```java
//    使用set
    int updateSupplier(Map<String,String> map);
```

Mapper.xml

```xml
<!--    使用set-->
    <update id="updateSupplier" parameterType="map">
        update commodity_supplier
        <set>
            <if test="supplierName != null">
                supplier_name = #{supplierName},
            </if>
            <if test="linkman != null">
                linkman = #{linkman}
            </if>
        </set>
        where supplier_no =#{supplierNo}
    </update>
```

测试：

```java
  @Test
    public void querySupplierBySet(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        CommoditySupplierMapper mapper = sqlSession.getMapper(CommoditySupplierMapper.class);
        HashMap<String, String> map = new HashMap<>();
        map.put("supplierNo","1111");
        map.put("supplierName","阿里巴巴");
        map.put("linkman","张勇");
        int i = mapper.updateSupplier(map);
        if (i>0){
            sqlSession.commit();
        }
        sqlSession.close();
    }
```

trim:

```xml
<trim prefix="WHERE" prefixOverrides="AND |OR ">
  ...
</trim>
```

等效where

```xml
<trim prefix="SET" suffixOverrides=",">
  ...
</trim>
```

等效于set

**所谓动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码**

### foreach

动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）

```xml
<select id="selectPostIn" resultType="domain.blog.Post">
  SELECT *
  FROM POST P
  WHERE ID in
  <foreach item="item" index="index" collection="list"
      open="(" separator="," close=")">
        #{item}
  </foreach>
</select>
```

* foreach 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。这个元素也不会错误地添加多余的分隔符，看它多智能！

* 提示：你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 *foreach*。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。

接口：

```java
//    使用foreach
    List<CommoditySupplier> querySupplierByForEach(Map map);
```

Mapper.xml

```xml
<!--
        使用foreach
        select * from commodity_supplier where id = '1111' or id ='2222'
-->
    <select id="querySupplierByForEach" parameterType="map" resultType="CommoditySupplier">
        select * from commodity_supplier
        <where>
            <foreach collection="ids" open="(" separator="or"  close=")" item="id">
                supplier_no = #{id}
            </foreach>
        </where>
    </select>
```

测试：

```java
    @Test
    public void querySupplierByForEach(){
        SqlSession sqlSession = MyBatisUtil.getSqlSession();
        CommoditySupplierMapper mapper = sqlSession.getMapper(CommoditySupplierMapper.class);
        HashMap<String, Object> map = new HashMap<>();
        ArrayList<String> list = new ArrayList<>();
        list.add("1111");
        list.add("2222");
        map.put("ids",list);
        List<CommoditySupplier> commoditySuppliers = mapper.querySupplierByForEach(map);
        for (CommoditySupplier commoditySupplier : commoditySuppliers) {
            System.out.println(commoditySupplier);
        }
        sqlSession.close();
    }
```

**动态SQL就是在拼接SQL语句，我们只需要保证SQL的正确性，按照SQL格式，去排列组合就可以了**

建议：

* 先在MySQL中写出完整的SQL，再对应的去修改成为我们的动态SQL实现通用即可





### SQL片段

有的时候，我们可能会将一些公共部分抽取出来，方便复用！

```xml
<!--    SQL片段-->
    <sql id="if-no-name">
        <if test="supplierNo != null">
            and supplier_no = #{supplierNo}
        </if>
        <if test="supplierName != null">
            and supplier_name = #{supplierName}
        </if>
    </sql>

<!--    使用if查询-->
    <select id="querySupplierByIf" parameterType="map" resultType="CommoditySupplier">
        select * from commodity_supplier where 1=1
--         引入SQL片段
        <include refid="if-no-name"></include>
    </select>

    <!--    使用if查询-->
    <select id="querySupplierByIf" parameterType="map" resultType="CommoditySupplier">
        select * from commodity_supplier where 1=1
        <if test="supplierNo != null">
            and supplier_no = #{supplierNo}
        </if>
        <if test="supplierName != null">
            and supplier_name = #{supplierName}
        </if>
    </select>
```

1. 使用SQL标签，抽取公共部分
2. 在需要的地方使用include标签引入即可

注意：

* 最好基于单表来定义SQL片段
* 不要存在where标签

## 缓存

### 简介



> 查询 ： 连接数据库，耗资源
>
> 一次查询的结果，给他暂存一个可以直接取到的地方 --> 内存：缓存
>
> 我们再次查询的相同数据的时候，直接走缓存，不走数据库了

1. 什么是缓存[Cache]？
   - 存在内存中的临时数据
   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题
2. 为什么使用缓存？
   - 减少和数据库的交互次数，减少系统开销，提高系统效率
3. 什么样的数据可以使用缓存？
   - 经常查询并且不经常改变的数据 【可以使用缓存】

### MyBatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存，缓存可以极大的提高查询效率。

- MyBatis系统中默认定义了两级缓存：

  一级缓存

  和

  二级缓存

  - 默认情况下，只有一级缓存开启（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提高可扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。

###  一级缓存

- 一级缓存也叫本地缓存：SqlSession，默认开启
  - 与数据库同一次会话期间查询到的数据会放在本地缓存中
  - 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库

测试步骤：

1. 开启日志

2. 测试在一个Session中查询两次记录

   ```java
       @Test
       public void test1() {
           SqlSession sqlSession = MybatisUtils.getSqlSession();
           UserMapper mapper = sqlSession.getMapper(UserMapper.class);
           User user = mapper.getUserById(1);
           System.out.println(user);
   
           System.out.println("=====================================");
   
           User user2 =  mapper.getUserById(1);
           System.out.println(user2 == user);
       }
   ```

3. 查看日志输出

   只查询了一次数据库

**缓存失效的情况：**

1. 查询不同的东西

2. 增删改操作，可能会改变原来的数据，所以必定会刷新缓存

3. 查询不同的Mapper.xml

4. 手动清理缓存

   ```java
   sqlSession.clearCache();
   ```

小结：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接关闭连接的时间段。一级缓存就是一个Map，用的时候直接去里拿、

### 二级缓存

- 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存
- 基于namespace级别的缓存，一个名称空间，对应一个二级缓存
- 工作机制
  - 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中
  - 如果会话关闭了，这个会员对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中
  - 新的会话查询信息，就可以从二级缓存中获取内容
  - 不同的mapper查询出的数据会放在自己对应的缓存（map）中

一级缓存开启（SqlSession级别的缓存，也称为本地缓存）

- 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
- 为了提高可扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来定义二级缓存。

步骤：

1. 开启全局缓存

   ```xml
   <!--显示的开启全局缓存-->
   <setting name="cacheEnabled" value="true"/>
   ```

2. 在Mapper.xml中使用缓存

   ```xml
   <!--在当前Mapper.xml中使用二级缓存，不设置参数-->
   <cache/>
   ```

   

   ```xml
   <!--
   	在当前Mapper.xml中使用二级缓存
   可用的清除策略有：
   	LRU – 最近最少使用：移除最长时间不被使用的对象。
   	FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
   	SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。
   	WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。
   	默认的清除策略是 LRU。
   -->
   <cache
          eviction="FIFO"
          flushInterval="60000"
          size="512"
          readOnly="true"/>
   ```

3. 测试

   ```java
   @Test
       public void test1() {
           SqlSession sqlSession = MybatisUtils.getSqlSession();
           SqlSession sqlSession2 = MybatisUtils.getSqlSession();
           UserMapper mapper = sqlSession.getMapper(UserMapper.class);
           UserMapper mapper2 = sqlSession.getMapper(UserMapper.class);
           User user = mapper.getUserById(1);
           System.out.println(user);
   		sqlSession.close();//sqlSession关闭，放入二级缓存
           System.out.println("=====================================");
   
           User user2 =  mapper2.getUserById(1);
           System.out.println(user2 == user);
           sqlSession2.close();
       }
   ```

   

   1. 问题：我们需要将实体类序列化，否则就会报错

      ```java
      1caused by: java.io.NotserializableException : pojo.user
      ```

      

   2. 必须是同一个Mapper.xml文件

**小结：**

- 只要开启了二级缓存，在同一个Mapper下就有效
- 所有的数据都会放在一级缓存中
- 只有当前会话提交，或者关闭的时候，才会提交到二级缓存中

### 缓存原理

原理：

1. 首先查询二级缓存
2. 二级缓存没有再查询一级缓存
3. 一级缓存中没有，再查询数据库
4. 从数据库中获取数据之后，先存入一级缓存（sqlSession）
5. 当sqlSession关闭的适合，存入二级缓存。

### 自定义缓存

> EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。

要在程序中使用ehcache：

1. 导包

   ```xml
   <dependency>
       <groupId>org.mybatis.caches</groupId>
       <artifactId>mybatis-ehcache</artifactId>
       <version>1.2.1</version>
   </dependency>
   ```

2. 在Mapper.xml中指定使用我们的ehcache缓存实现

   ```xml
   <cache type="org.mybatis.caches.ehcache.EhcacheCache"/>
   ```

3. 写配置文件

   ehcache.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"
            updateCheck="false">
       <!--
          diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：
          user.home – 用户主目录
          user.dir  – 用户当前工作目录
          java.io.tmpdir – 默认临时文件路径
        -->
       <diskStore path="java.io.tmpdir/Tmp_EhCache"/>
       <!--
          defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
        -->
       <!--
         name:缓存名称。
         maxElementsInMemory:缓存最大数目
         maxElementsOnDisk：硬盘最大缓存个数。
         eternal:对象是否永久有效，一但设置了，timeout将不起作用。
         overflowToDisk:是否保存到磁盘，当系统当机时
         timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
         timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
         diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. Thedefault valueis false.
         diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
         diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
         memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
         clearOnFlush：内存数量最大时是否清除。
         memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
         FIFO，firstin firstout，这个是大家最熟的，先进先出。
         LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
         LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
      -->
       <defaultCache
               eternal="false"
               maxElementsInMemory="10000"
               overflowToDisk="false"
               diskPersistent="false"
               timeToIdleSeconds="1800"
               timeToLiveSeconds="259200"
               memoryStoreEvictionPolicy="LRU"/>
     
       <cache
               name="cloud_user"
               eternal="false"
               maxElementsInMemory="5000"
               overflowToDisk="false"
               diskPersistent="false"
               timeToIdleSeconds="1800"
               timeToLiveSeconds="1800"
               memoryStoreEvictionPolicy="LRU"/>
     
   </ehcache>
   ```

   **一般使用Redis做缓存（K-V），一般不这个层面做缓存，这个层面缓存效率太低了**