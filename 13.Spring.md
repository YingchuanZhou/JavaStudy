# Spring
## 简介
* Spring：春天 ------->软件行业的春天
* 2002年，首次推出了Spring框架的雏形：interface21框架
* Spring框架即以interface21框架为基础，经过重新设计，并且不断丰富内涵，于2004年3月24日，发布了1.0正式版。
* Rob Johnson，Spring Framework创始人，著名作者，他是悉尼大学的博士，然而他的专业不是计算机而是音乐学。
* Spring 理念：使现有的技术更加容易使用，本身式一个大杂烩，整合了现有的技术框架。
* SSH： Struct2 + Spring + Hibernate
* SSM：SpringMVC + Spring + Mybatis
官网：https://spring.io/projects/spring-framework#overview
官方下载地址：
GitHub：https://github.com/spring-projects/spring-framework

导包：
```xml
<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>5.3.9</version>
</dependency>


<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>5.3.9</version>
</dependency>

```
## 优点
* Spring是一个开源免费的框架（容器）

* Spring是一个轻量级的、非入侵式的框架

* 核心是：控制反转（IOC），面向切面编程（AOP）

* 支持事务处理，对框架整合的支持

总结：Spring就是一个轻量级的控制反转（IOC），面向切面编程（AOP）的框架
## 组成
 * 核心容器：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用控制反转 （IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。

* Spring Context：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。

* Spring AOP：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。

* Spring DAO：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。

* Spring ORM：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。

* Spring Web 模块：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。

*  Spring MVC 框架：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。

* Spring 框架的功能可以用在任何 J2EE 服务器中，大多数功能也适用于不受管理的环境。Spring 的核心要点是：支持不绑定到特定 J2EE 服务的可重用业务和数据访问对象。毫无疑问，这样的对象可以在不同 J2EE 环境 （Web 或 EJB）、独立应用程序、测试环境之间重用。
## 扩展
在Spring官网中有一个介绍，现在化Java的开发就是基于Spring的开发.
* SpringBoot：构建一切
	* 一个快速开发的脚手架。
	* 基于SpringBoot可以快速开发单个微服务。
	* 约定大于配置
* SpringCloud：协调一切
	* SpringCloud是基于SpringBoot实现的。
* SpringClod Data Flow：连接一切
* 现在大多数公司都在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要掌握Spring和SpringMVC

# IOC理论推导（Inversion of Control）

1. UserDao 接口
2. UserDaoImpl 实现类
3. UserService 业务接口
4. UserServiceImpl 业务实现类

在之前的业务中，用户的需求可能会影响代码，我们需要根据用户的需求修改与那代码，如果程序非常大，修改需求的带价十分昂贵。



程序主动创建对象实现：

```java
private UserDao userDao = new UserDao();
```



我们可以使用Set接口实现，已经发生了革命性的变化！

```java
private UserDao userDao;

//利用set进行动态注入
public void setUserDao(UserDao userDao){
    this.userDao = userDao;
}
```

* 之前，程序是主动创建对象！控制权在程序员手中！
* 使用set注入方式之后，程序不再具有主动性，而是变成了被动接受的对象。

这种思想，从本质上解决了问题，我们程序员不需要再去管理创建对象。系统耦合性降低，可以更加专注的在业务的始线上，这就是IOC(控制反转)的原型。

# IOC本质

**控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法**，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。



![图片](13.Spring.assets/640)

**IoC是Spring框架的核心内容**，使用多种方式完美的实现了IoC，可以使用XML配置，也可以使用注解，新版本的Spring也可以零配置实现IoC。

Spring容器在初始化时先读取配置文件，根据配置文件或元数据创建与组织对象存入容器中，程序使用时再从Ioc容器中取出需要的对象。

![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7KtDiaOqFy5ourlJ8FTVV2FF67dfeA6cRT7EiafNcibWyf57SGpkZ01JnpiaaicNB1ibBjGaicAvayKEWJ0A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。

**控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。**

# HelloSpring

​	导入Jar包

注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .

```xml
<dependency>
   <groupId>org.springframework</groupId>
   <artifactId>spring-webmvc</artifactId>
   <version>5.1.10.RELEASE</version>
</dependency>
```

> 编写代码

1、编写一个Hello实体类

```java
public class Hello {
   private String name;

   public String getName() {
       return name;
  }
   public void setName(String name) {
       this.name = name;
  }

   public void show(){
       System.out.println("Hello,"+ name );
  }
}
```

2、编写我们的spring文件 , 这里我们命名为beans.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

   <!--bean就是java对象 , 由Spring创建和管理-->
   <bean id="hello" class="com.kuang.pojo.Hello">
       <property name="name" value="Spring"/>
   </bean>

</beans>
```

3、我们可以去进行测试了 .

```java
@Test
public void test(){
   //解析beans.xml文件 , 生成管理相应的Bean对象
   ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
   //getBean : 参数即为spring配置文件中bean的id .
   Hello hello = (Hello) context.getBean("hello");
   hello.show();
}
```



> 思考

- Hello 对象是谁创建的 ?  【hello 对象是由Spring创建的
- Hello 对象的属性是怎么设置的 ?  hello 对象的属性是由Spring容器设置的

这个过程就叫控制反转 :

- 控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的
- 反转 : 程序本身不创建对象 , 而变成被动的接收对象 .

依赖注入 : 就是利用set方法来进行注入的.

 IOC是一种编程思想，由主动的编程变成被动的接收

可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .



> 修改案例一

我们在案例一中， 新增一个Spring配置文件beans.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd">

   <bean id="MysqlImpl" class="com.kuang.dao.impl.UserDaoMySqlImpl"/>
   <bean id="OracleImpl" class="com.kuang.dao.impl.UserDaoOracleImpl"/>

   <bean id="ServiceImpl" class="com.kuang.service.impl.UserServiceImpl">
       <!--注意: 这里的name并不是属性 , 而是set方法后面的那部分 , 首字母小写-->
       <!--引用另外一个bean , 不是用value 而是用 ref-->
       <property name="userDao" ref="OracleImpl"/>
   </bean>

</beans>
```

测试！

```java
@Test
public void test2(){
   ApplicationContext context = new ClassPathXmlApplicationContext("beans.xml");
   UserServiceImpl serviceImpl = (UserServiceImpl) context.getBean("ServiceImpl");
   serviceImpl.getUser();
}
```


**OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 ! **

# IOC创建对象的方式

1. 默认使用无参构造创建对象

```xml
<!--    使用无参构造-->
    <bean id="user" class="pojo.User">
<!--        这里调用的是set方法-->
        <property name="name" value="周迎川"/>
    </bean>

```



1. 使用有参构造创建对象

   1. 下标赋值

   ```xml
   <!--    使用下标赋值-->
       <bean id="user" class="pojo.User">
           <constructor-arg index="0" value="周迎川"/>
       </bean>
   ```

   2. 通过类型赋值，不建议使用

   ```xml
   <!--    通过类型赋值，不建议使用-->
       <bean id="user" class="pojo.User">
           <constructor-arg type="java.lang.String" value="周迎川"/>
       </bean>
   ```

   3. 直接通过参数名赋值

   ```xml
   <!--    直接通过参数名赋值-->
       <bean id="user" class="pojo.User">
           <constructor-arg name="name" value="周迎川"/>
       </bean>
   ```

测试：

```java
public class Test {

    public static void main(String[] args) {
        //        Spring容器，里面有很多对象，但是每个对象的实例只保存一个
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("beans.xml");
        User user = (User) applicationContext.getBean("user");

        user.show();
    }
}
```



总结：在配置文件加载的时候，容器中管理的对象就已经初始化了！

# Spring配置

## 别名

```xml
<!--    如果添加了别名，我们也可以使用别名获取到这个对象-->
    <alias name="user" alias="userNew"/>
```



## Bean的配置

```xml
<!--
        id：bean的唯一标识符，也相当于对象的名称
        class：bean对象所对应的全限定名：包名+类名
        name：也是别名，而且name更加高级，可以同时取多个别名，分隔符也可以是空格、逗号、分号
-->
    <bean id="user2" class="pojo.User" name="userT,u2;us2 use4">
        <!--        这里调用的是set方法-->
        <property name="name" value="周迎川"/>
    </bean>
```



## import

这个import，一般用于团队开发使用，他可以将多个配置文件，导入合并为一个

假设现在有3个人开发，写了3个beans.xml文件，我们可以利用import将三个合并为一个总的

直接在applicationContext.xml中import进3个文件

```xml
<import resource="beans.xml"/>
<import resource="beans2.xml"/>
<import resource="beans3.xml"/>
```

使用时直接使用总的配置即可。

配置：

applicationContext.xml:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

<!--    导入多个配置文件合并成为一个，用于多人协同开发-->
        <import resource="beans.xml"/>
</beans>
```

beans.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

<!--    使用无参构造-->
    <bean id="user" class="pojo.User">
<!--        这里调用的是set方法-->
        <property name="name" value="周迎川"/>
    </bean>

<!--    如果添加了别名，我们也可以使用别名获取到这个对象-->
    <alias name="user" alias="userNew"/>



<!--    使用下标赋值-->
<!--    <bean id="user" class="pojo.User">-->
<!--        <constructor-arg index="0" value="周迎川"/>-->
<!--    </bean>-->


<!--    通过类型赋值，不建议使用-->
<!--    <bean id="user" class="pojo.User">-->
<!--        <constructor-arg type="java.lang.String" value="周迎川"/>-->
<!--    </bean>-->


<!--    直接通过参数名赋值-->
<!--    <bean id="user" class="pojo.User">-->
<!--        <constructor-arg name="name" value="周迎川"/>-->
<!--    </bean>-->


<!--
        id：bean的唯一标识符，也相当于对象的名称
        class：bean对象所对应的全限定名：包名+类名
        name：也是别名，而且name更加高级，可以同时取多个别名，分隔符也可以是空格、逗号、分号
-->
    <bean id="user2" class="pojo.User" name="userT,u2;us2 use4">
        <!--        这里调用的是set方法-->
        <property name="name" value="周迎川"/>
    </bean>
</beans>
```

测试：

```java
public class Test {

    public static void main(String[] args) {
//        Spring容器，里面有很多对象，但是每个对象的实例只保存一个
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        User user = (User) applicationContext.getBean("user");
        User user2 = (User) applicationContext.getBean("user");
        System.out.println(user.equals(user2));
        user.show();
    }
}

public class Test {

    public static void main(String[] args) {
//        Spring容器，里面有很多对象，但是每个对象的实例只保存一个
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");
        User user = (User) applicationContext.getBean("user");
        User user2 = (User) applicationContext.getBean("user");
        System.out.println(user.equals(user2));
        user.show();
    }
}

```

# DI（依赖注入）

## 构造器注入

前面讲的使用constructor-arg参数就是使用构造器注入

```xml
<!--    直接通过参数名赋值-->
    <bean id="user" class="pojo.User">-->
       <constructor-arg name="name" value="周迎川"/>
    </bean>
```



## Set方式注入【重点】

* 依赖注入：Set注入
  * 依赖：bean对象的创建依赖于容器
  * 注入：bean对象中的所有属性由容器注入

【环境搭建】

1. 复杂类型

```java
public class Address {

    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}
```



2. 真实测试对象

```java
public class Student {

    private String name;
    private Address address;
    private String[] books;
    private List<String> hobbies;
    private Map<String,String> card;
    private Set<String> games;
    private String wife;
    private Properties info;
}
```

3. applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="student" class="com.zhou.pojo.Student">
<!--        1.使用普通值注入-->
        <property name="name" value="周迎川"/>
    </bean>
</beans>
```

4. 测试类

完善applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="address" class="com.zhou.pojo.Address">
        <property name="address" value="重庆"/>
    </bean>

    <bean id="student" class="com.zhou.pojo.Student">
<!--        1.使用普通值注入-->
        <property name="name" value="周迎川"/>
<!--        第二种，Bean注入，ref-->
        <property name="address" ref="address"/>
<!--        第三种，数组注入-->
        <property name="books">
            <array>
                <value>Java</value>
                <value>Python</value>
                <value>C++</value>
                <value>Spring</value>
            </array>
        </property>
<!--        List注入-->
        <property name="hobbies">
            <list>
                <value>写代码</value>
                <value>看电影</value>
                <value>听歌</value>
                <value>学习</value>
            </list>
        </property>
<!--        Map注入-->
        <property name="card">
            <map>
                <entry key="身份证" value="500235199911152222"/>
                <entry key="银行卡" value="6215281055252724"/>
            </map>
        </property>
<!--        Set注入-->
        <property name="games">
            <set>
                <value>LOL</value>
                <value>CF</value>
                <value>QQ飞车</value>
            </set>
        </property>
<!--        null注入-->
        <property name="wife">
            <null/>
        </property>
<!--        Properties注入
            key=value
            key=value
            key=value
-->
        <property name="info">
            <props>
                <prop key="学号">631907060434</prop>
                <prop key="性别">男</prop>
                <prop key="姓名">周迎川</prop>
            </props>
        </property>
    </bean>

</beans>
```

测试：

```java
public class Test {
    public static void main(String[] args) {

        ApplicationContext applicationContext  = new ClassPathXmlApplicationContext("applicationContext.xml");

        Student student = (Student) applicationContext.getBean("student");

        System.out.println(student);

        /*
        Student{
            name='周迎川',
            address=Address{
            address='重庆'
             },
             books=[Java, Python, C++, Spring],
            hobbies=[写代码, 看电影, 听歌, 学习],
             card={
                身份证=500235199911152222,
                银行卡=6215281055252724
            },
            games=[LOL, CF, QQ飞车],
            wife='null',
            info={
                姓名=周迎川,
                学号=631907060434,
                性别=男
            }
         }

         */
    }
}
```



## 拓展方式注入

### C命名空间注入

### P命名空间注入



使用：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xmlns:c="http://www.springframework.org/schema/c"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

<!--    p命名空间注入，可以直接注入属性的值：property-->
    <bean id="user" class="com.zhou.pojo.User" p:name="周迎川" p:age="21"/>

    <!--        c命名空间注入，是通过有参构造器注入，constructor-args-->
    <bean id="user2" class="com.zhou.pojo.User" c:name="zyc" c:age="21"/>

</beans>
```

测试：

```java
  @org.junit.Test
    public void test(){
        ApplicationContext context = new ClassPathXmlApplicationContext("userbeans.xml");
        User user = context.getBean("user", User.class);
        System.out.println(user);
    }
    @org.junit.Test
    public void test2(){
        ApplicationContext context = new ClassPathXmlApplicationContext("userbeans.xml");
        User user = context.getBean("user2", User.class);
        System.out.println(user);
    }
```

注意：使用p命名空间和c命名空间不能直接使用，需要导入xml约束

```xml
xmlns:p="http://www.springframework.org/schema/p"
xmlns:c="http://www.springframework.org/schema/c"
```

##  Bean的作用域

1. 单例模式（Spring默认的机制）：只有一个实例对象

```xml
<!--    p命名空间注入，可以直接注入属性的值：property-->
    <bean id="user" class="com.zhou.pojo.User" p:name="周迎川" p:age="21" scope="singleton"/>

```

2. 原型模式：每次从容器中get的时候，都会产生一个新对象

```xml
<!--    p命名空间注入，可以直接注入属性的值：property-->
    <bean id="user" class="com.zhou.pojo.User" p:name="周迎川" p:age="21" scope="property"/>
```

3. 其余的request、session、application、websocket，这些都只是在web开发中使用到

# Bean的自动装配（Autowired）

* 自动装配是Spring满足Bean依赖的一种方式
* Spring会在上下文中自动寻找，并自动给bean装配属性

在Spring中有三种装配方式

1. 在xml中显示的配置
2. 在Java中显示配置
3. 隐式的自动装配bean【重点】

## 测试

环境搭建：

* 一个人有两个宠物

cat：

```java
public class Cat {

    public void shout(){
        System.out.println("miao~");
    }
}
```

dog:

```java
public class Dog {

    public void shout(){
        System.out.println("wang~");
    }
}

```

people:

```java
public class People {

    private Cat cat;
    private Dog dog;
    private String name;

    public Cat getCat() {
        return cat;
    }

    public void setCat(Cat cat) {
        this.cat = cat;
    }

    public Dog getDog() {
        return dog;
    }

    public void setDog(Dog dog) {
        this.dog = dog;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "People{" +
                "cat=" + cat +
                ", dog=" + dog +
                ", name='" + name + '\'' +
                '}';
    }
}
```

### 在xml中显示配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="cat" class="com.zhou.pojo.Cat"/>
    <bean id="dog" class="com.zhou.pojo.Dog"/>
    <bean id="people" class="com.zhou.pojo.People">
        <property name="name" value="周迎川"/>
        <property name="cat" ref="cat"/>
        <property name="dog" ref="dog"/>
    </bean>

</beans>
```

### byName自动装配

```xml
<!--    利用Spring自动装配 autowired-->
    <bean id="cat" class="com.zhou.pojo.Cat"/>
    <bean id="dog" class="com.zhou.pojo.Dog"/>
<!--
        byName:会自动在容器上下文寻找,和自己对象set方法后面的值对应的bean id
-->
    <bean id="people" class="com.zhou.pojo.People" autowire="byName">
        <property name="name" value="周迎川"/>
    </bean>
```

### byType自动装配

```xml
<!--    利用Spring自动装配 autowired-->
    <bean id="cat" class="com.zhou.pojo.Cat"/>
    <bean id="dog" class="com.zhou.pojo.Dog"/>
<!--
        byName:会自动在容器上下文寻找,和自己对象set方法后面的值对应的bean id
        byName:会自动在容器上下文寻找,和自己对象属性类型相同的bean,但是这种方式每个类型的对象只能有一个
-->
<!--    <bean id="people" class="com.zhou.pojo.People" autowire="byName">-->
    <bean id="people" class="com.zhou.pojo.People" autowire="byType">
        <property name="name" value="周迎川"/>
    </bean>
```

小结：

* byName的时候，需要保证所有的bean的id唯一，并且这个bean要和自动注入的属性的set方法的值一致
* byType的时候，需要保证所有的bean的class唯一，并且这个bean需要和自动注入的属性的类型一致

### 使用注解实现自动装配

jdk1.5支持注解，Spring2.5支持注解

使用注解：

1. 导入约束：

   ` xmlns:context="http://www.springframework.org/schema/context"`

2. 配置注解的支持：` <context:annotation-config/>`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```

**@Autowired**
直接在属性上使用即可，也可以在Set方法上使用

使用Autowired我们可以不用编写Set方法，前提是你这个自动装配的属性在 IOC （Spring）容器中存在，并且符合byName

科普：

```java
@Nullable   字段标记了这个注解，说明这个字段可以为null
```

```java
public @interface Autowired {

	/**
	 * Declares whether the annotated dependency is required.
	 * <p>Defaults to {@code true}.
	 */
	boolean required() default true;

}
```

测试代码：

```java
public class People {

//    如果显示定义了Autowired的required属性值为false,说明这个对象可以为null,否则不允许为空
    @Autowired(required = false)
    private Cat cat;
    @Autowired
    private Dog dog;
    private String name;
```

**如果@Autowired自动装配环境比较复杂，自动装配无法通过一个注解（@Autowired）完成的时候，我们可以使用@Qualifier（value="xxx"去配合@Autowired使用，指定一个唯一的bean对象注入**

其中javax包下的注解**@Resource**也可以实现自动装配，该注解是先通过byName方式，找不到再通过byType方式，都不成功就报错，注解中的name属性也可以指定唯一装配对象

@Autowired和@Resource异同：

* 都是用来实现自动装配的，都可以放在属性字段上
* @Autowired 通过byType的方式实现，而且必须要求这个对象存在，如果要使得这个属性可以为空，必须要使用@Nullable注解
* @Resource注解是先通过byName方式，找不到再通过byType方式，都不成功就报错，注解中的name属性也可以指定唯一装配对象
* 执行顺序不同：@Autowired通过byType实现，@Resource首先通过byName实现

# 使用注解开发

在Spring4之后，要使用注解开发，必须导入AOP的包，使用注解需要导入context约束，增加注解支持

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:context="http://www.springframework.org/schema/context"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        https://www.springframework.org/schema/context/spring-context.xsd">

    <context:annotation-config/>

</beans>
```



## 1. Bean





## 2. 属性如何注入

```java
//等价于    <bean id="user" class="com.zhou.pojo.User"/>
//@Component  组件
@Component
public class User {

//    相当于 <property name="name" value="周迎川"/>
    @Value("周迎川")
    public String name ;


//    该注解也可以用在Set方法上面
    @Value("周迎川2")
    public void setName(String name) {
        this.name = name;
    }
}

```





## 3. 衍生的注解

@Component有几个衍生注解，我们在web开发中，会按照MVC三层架构分层

* mapper	【@Repository】
* service      【@Service】
* controller    【@Controller】

这四个注解功能都是一样的，都是代表将某个类注册到Spring容器中，装配Bean

## 4. 自动装配

* @Autowired   ：自动装配通过类型，名字
  * 如果@Autowired不能唯一自动装配上属性，则需要通过@Qualifier(Value = "xxx")
* @Nullable  ：字段标记了该注解说明该字段可以为null
* @Resource  ：自动装配通过名字，类型





## 5. 作用域

@Scope("")可选值为：singleton，property，代表单例和原型

```java
//等价于    <bean id="user" class="com.zhou.pojo.User"/>
//@Component  组件
@Component
@Scope("singleton")
public class User {

//    相当于 <property name="name" value="周迎川"/>
    @Value("周迎川")
    public String name ;


//    该注解也可以用在Set方法上面
    @Value("周迎川2")
    public void setName(String name) {
        this.name = name;
    }
}
```





## 6. 小结

xml与注解：

* xml更加万能，适用于任何场合，维护简单方便
* 注解：不是自己的类使用不了，维护相对复杂

xml与注解的最佳实践：

* xml用来管理bean
* 注解只负责完成属性注入
* 在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解支持、开启包扫描

```xml
<!--    指定要扫描的包,这个包下的注解就会生效-->
    <context:component-scan base-package="com.zhou"/>
<!--    开启注解支持-->
    <context:annotation-config/>
```

# 使用Java的方式配置Spring

完全不使用Spring的xml配置了，全部交给Java做

JavaConfig是Spring的一个子项目，在Spring 4 之后，他成为了一个核心功能

User：

```java
//这里这个注解的意思，就是说明这个类被Spring接管了，注册到了容器
@Component
public class User {

    @Value("周迎川")
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

MyConfig:

```java
//这个也会被Spring容器托管，注册到容器中，因为本身就是一个@Component
//@Configuration 代表这是一个配置类和之前的beans.xml差不多
@Configuration
//声明扫描包
@ComponentScan("com.zhou.pojo")
//如果有多个bean，将多个bean导入
@Import(MyConfig2.class)
public class MyConfig {

//    注册一个bean，就相当于我们之前写的一个bean标签
//    这个方法的名字就相当于bean标签中的id属性
//    这个方法的返回值就相当于bean标签的class属性
    @Bean
    public User getUser(){
        return  new User();//就是返回要注入bean的对象
    }
}
```

MyConfig2:

```java
@Configuration
public class MyConfig2 {
}

```

Test:

```java
public class Test {
    public static void main(String[] args) {
//        如果完全使用了配置类去做，我们只能通过AnnotationConfig 上下文获取容器，通过配置类的class对象加载
        ApplicationContext context = new AnnotationConfigApplicationContext(MyConfig.class);
        User getUser = (User) context.getBean("getUser");

        System.out.println(getUser.getName());
    }
}

```

这种纯Java的配置方式，在SpringBoot中随处可见

# 代理模式

为什么要学代理模式？

​	因为这就是Spring AOP的底层！【Spring AOP 和 Spring MVC】

代理模式分类：

* 静态代理
* 动态代理

## 静态代理

角色分析：

* 抽象角色：一般会使用接口或者抽象类来解决
* 真实角色：被代理的角色
* 代理角色：代理真实角色，代理真实角色后，我们会进行一些附属操作。
* 客户：访问代理对象的人

客户租房子只需要找中介，不需要直接找房东

实现步骤：

1. 接口

```java
//租房
public interface Rent {

    public void rent();
}

```

2. 真实角色

```java
//房东
public class Host implements Rent{


    @Override
    public void rent() {
        System.out.println("房东出租房子！！！");
    }
}

```



3. 代理角色

```java
package com.zhou.demo1;

public class Proxy implements Rent{

    private Host host;

    public Proxy() {
    }

    public Proxy(Host host) {
        this.host = host;
    }

    public Host getHost() {
        return host;
    }

    public void setHost(Host host) {
        this.host = host;
    }


    @Override
    public void rent() {
        host.rent();
        seeHouse();
        fare();
    }

//    中介还能进行一些附属操作
//   比如看房，收中介费
    public void seeHouse(){
        System.out.println("中介看房");
    }

    public void fare(){
        System.out.println("中介收中介费");
    }
}

```



4. 客户端访问代理角色

```java
//客户
public class Client {

    public static void main(String[] args) {
//        房东要出租房子
        Host host1 = new Host();
//代理帮助房东出租房子，并且还有一些附属操作
        Proxy proxy = new Proxy(host1);
//        不需要找房东，直接找代理也能租到房东的房子
        proxy.rent();
    }

}
```



静态代理模式的好处：

* 可以使真实角色的操作更加纯粹，不用去关注一些公共的业务
* 公共的业务就可以交给代理，实现了业务的分工
* 公共业务发生扩展的时候，方便集中管理

缺点：

* 一个真实角色就会产生一个代理角色，代码量会翻倍---->开发效率会变低

  

## 再理解静态代理

接口：

```java
public interface UserService {

    public void add();
    public void delete();
    public void update();
    public void query();
}

```

真实角色：

```java
public class UserServiceImpl implements UserService{
    @Override
    public void add() {
        System.out.println("增加用户");
    }

    @Override
    public void delete() {
        System.out.println("删除用户");
    }

    @Override
    public void update() {
        System.out.println("修改用户");
    }

    @Override
    public void query() {
        System.out.println("查询用户");
    }
}
```

代理角色：

```java
public class UserServiceProxy implements UserService{

    UserServiceImpl userServiceImpl;

    public void setUserServiceImpl(UserServiceImpl userServiceImpl) {
        this.userServiceImpl = userServiceImpl;
    }

    @Override
    public void add() {
        log("add");
        userServiceImpl.add();
    }

    @Override
    public void delete() {
        log("delete");
        userServiceImpl.delete();
    }

    @Override
    public void update() {
        log("update");
        userServiceImpl.update();
    }

    @Override
    public void query() {
        log("query");
        userServiceImpl.query();
    }

//    新增加一个日志功能，尽量不要去改变已经有的代码
    public void log(String msg){
        System.out.println("[Debug] 使用了"+msg+"方法");
    }
}
```

客户：

```java
public class Client {
    public static void main(String[] args) {
        UserServiceImpl userService = new UserServiceImpl();

//        通过代理去做
        UserServiceProxy userServiceProxy = new UserServiceProxy();
        userServiceProxy.setUserServiceImpl(userService);

        userServiceProxy.add();
    }
}

```

## 动态代理

* 动态代理和静态代理角色一样
* 动态代理的代理类是动态生成的，不是我们直接写好的
* 动态代理分为两大类：基于接口的动态代理，基于类的动态代理
  * 基于接口： JDK动态代理【现在学的】
  * 基于类：cglib
  * Java字节码实现：Javasist

需要了解两个类：Proxy：代理    InvocationHandler：调用处理程序

Rent：

```java
//租房
public interface Rent {

    public void rent();
}

```

Host:

```java
//房东
public class Host implements Rent {


    @Override
    public void rent() {
        System.out.println("房东出租房子！！！");
    }
}

```

ProxyInvocationHandler:

```java
//用这个类自动动态生成代理类
public class ProxyInvocationHandler implements InvocationHandler {

//    被代理的接口
    private Rent rent;

    public void setRent(Rent rent) {
        this.rent = rent;
    }

    public ProxyInvocationHandler() {
    }

    //    生成得到的代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),rent.getClass().getInterfaces(),this);
    }

//    处理代理实例并且返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
//        动态代理的本质就是使用反射机制实现
        seeHouse();
        Object result = method.invoke(rent, args);
        fare();
        return result;
    }

    public void seeHouse(){
        System.out.println("中介看房子");
    }

    public void fare(){
        System.out.println("中介收费");
    }
}
```

Client:

```java
public class Client {

    public static void main(String[] args) {
        //    真实角色
        Host host = new Host();

//    代理角色：现在没有
        ProxyInvocationHandler pih =  new ProxyInvocationHandler();
//   通过调用程序处理角色来处理我们要调用的接口对象
        pih.setRent(host);

//    得到代理对象,是动态生成的并没有写
        Rent proxy = (Rent) pih.getProxy();
        proxy.rent();
    }
}

```





动态代理的好处：

* 可以使真实角色的操作更加纯粹，不用去关注一些公共的业务
* 公共的业务就可以交给代理，实现了业务的分工
* 公共业务发生扩展的时候，方便集中管理
* 一个动态代理类代理的是一个接口，一般就是对应的一类业务
* 一个动态代理类可以代理多个类，只要是实现了同一个接口即可。

## 在理解动态代理

UserService:

```java
public interface UserService {

    public void add();
    public void delete();
    public void update();
    public void query();
}
```

UserServiceImpl:

```java
public class UserServiceImpl implements UserService{
    @Override
    public void add() {
        System.out.println("增加用户");
    }

    @Override
    public void delete() {
        System.out.println("删除用户");
    }

    @Override
    public void update() {
        System.out.println("修改用户");
    }

    @Override
    public void query() {
        System.out.println("查询用户");
    }
}

```

ProxyInvocationHandler:

```java
//用这个类自动动态生成代理类
public class ProxyInvocationHandler implements InvocationHandler {

//    被代理的接口
    private Object target;

    public void setTarget(Object target) {
        this.target = target;
    }

    public ProxyInvocationHandler() {
    }

    //    生成得到的代理类
    public Object getProxy(){
        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);
    }

//    处理代理实例并且返回结果
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
//        动态代理的本质就是使用反射机制实现
        log(method.getName());
        Object result = method.invoke(target, args);
        return result;
    }

    public void log(String msg){
        System.out.println("[Debug] 使用了"+msg+"方法");
    }
}

```

Client:

```java
public class Client {
    public static void main(String[] args) {
//        真实角色
        UserServiceImpl userService = new UserServiceImpl();
//代理角色不存在
        ProxyInvocationHandler proxyInvocationHandler = new ProxyInvocationHandler();
        proxyInvocationHandler.setTarget(userService);//设置需要代理的对象
//        动态生成代理类
        UserService proxy = (UserService) proxyInvocationHandler.getProxy();
        proxy.add();

    }
}
```

# AOP 面向切面编程

> 什么是AOP

AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。



![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHf5pmH30gj6mZm81PC7iauicFu55sicJtspU7K3vTCVdZCDTSHq7D5XHlw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

> Aop在Spring中的作用

提供声明式事务；允许用户自定义切面

以下名词需要了解下：

- 横切关注点：跨越应用程序多个模块的方法或功能。即是，与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。如日志 , 安全 , 缓存 , 事务等等 ....
- 切面（ASPECT）：横切关注点 被模块化 的特殊对象。即，它是一个类。
- 通知（Advice）：切面必须要完成的工作。即，它是类中的一个方法。
- 目标（Target）：被通知对象。
- 代理（Proxy）：向目标对象应用通知之后创建的对象。
- 切入点（PointCut）：切面通知 执行的 “地点”的定义。
- 连接点（JointPoint）：与切入点匹配的执行点。



![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHVOZ1JpRb7ViaprZCRXsUbH0bZpibiaTjqib68LQHOWZicSvuU8Y1dquUVGw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

SpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice:



![图片](https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7JAeTYOaaH6rZ6WmLLgwQLHbAWH8haUQeJ0LVBxxX0icC5TZlBkEBGibibey7jFrCbibPzQcRhkNFcGAA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

即 Aop 在 不改变原有代码的情况下 , 去增加新的功能 .



> 使用Spring实现Aop

【重点】使用AOP织入，需要导入一个依赖包！

```xml
<!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver -->
<dependency>
   <groupId>org.aspectj</groupId>
   <artifactId>aspectjweaver</artifactId>
   <version>1.9.4</version>
</dependency>
```

方式一：使用元生Spring API接口【主要是SpringAPI接口实现】

UserService:

```java
public interface UserService {
    public void add();
    public void delete();
    public void update();
    public void query();
}
```

UserServiceImpl:

```java
public class UserServiceImpl implements UserService{
    @Override
    public void add() {
        System.out.println("增加用户");
    }

    @Override
    public void delete() {
        System.out.println("删除用户");
    }

    @Override
    public void update() {
        System.out.println("修改用户");
    }

    @Override
    public void query() {
        System.out.println("查询用户");
    }
}

```



Log

```java
public class Log implements MethodBeforeAdvice {

//    method:要执行目标对象的方法
//    args：参数
//    target：目标对象
    @Override
    public void before(Method method, Object[] args, Object target) throws Throwable {
        System.out.println(target.getClass().getName()+"的"+method.getName()+"被执行了");
    }
}

```



AfterLog

```java
public class AfterLog implements AfterReturningAdvice {
    @Override
    public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {
        System.out.println("执行了"+method.getName()+"方法，返回结果为："+returnValue);
    }
}

```

applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

<!--注册bean-->
    <bean id="userService" class="com.zhou.service.UserServiceImpl"/>
    <bean id="log" class="com.zhou.log.Log"/>
    <bean id="afterLog" class="com.zhou.log.AfterLog"/>

<!--    方式一：使用原生的Spring API接口-->
<!--    配置aop：需要导入aop的约束-->
    <aop:config>
<!--
        切入点：
        expression:表达式
        execution(要执行的位置 * * * * * )
-->
        <aop:pointcut id="pointcut" expression="execution(* com.zhou.service.UserServiceImpl.*(..))"/>

<!--        执行环绕增强-->
        <aop:advisor advice-ref="log" pointcut-ref="pointcut"/>
        <aop:advisor advice-ref="afterLog" pointcut-ref="pointcut"/>
    </aop:config>
</beans>
```

Test:

```java
public class Test {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
//       注意： 动态代理代理的是接口
        UserService userService = (UserService) context.getBean("userService");
        userService.add();
    }
}
```



方式二：自定义来实现AOP【主要是切面定义】

DiyPointCut

```java
public class DiyPointCut {

    public void before(){
        System.out.println("======方法执行前=======");
    }

    public void after(){
        System.out.println("======方法执行后=======");
    }
}

```

applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">
<!--    方式二：自定义类-->
    <bean id="diy" class="com.zhou.diy.DiyPointCut"/>

    <aop:config>
<!--        自定义切面，ref 引用要引用的类-->
        <aop:aspect ref="diy">
<!--            切入点-->
            <aop:pointcut id="point" expression="execution(* com.zhou.service.UserServiceImpl.*(..))"/>
<!--           通知-->
            <aop:before method="before" pointcut-ref="point"/>
            <aop:after method="after" pointcut-ref="point"/>
        </aop:aspect>
    </aop:config>

</beans>
```

方式三：使用注解实现

AnnotationPointCur:

```java
//使用注解方式实现AOP
@Aspect//标记这个类是一个切面
public class AnnotationPointCut {

    @Before("execution(* com.zhou.diy.AnnotationPointCut.*(..))")
    public void before(){
        System.out.println("======方法执行前=======");
    }

    @After("execution(* com.zhou.diy.AnnotationPointCut.*(..))")
    public void after(){
        System.out.println("======方法执行后=======");
    }

//在环绕增强中，我们可以给定一个参数，代表我们要获取处理切入的点
    @Around("execution(* com.zhou.diy.AnnotationPointCut.*(..))")
    public void around(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("环绕前");
        Signature signature = joinPoint.getSignature();//获得签名
        System.out.println(signature);
//        执行方法
        joinPoint.proceed();

        System.out.println("环绕后");
    }
}
```

applicationContext.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">
<!--    方式三：使用注解的方式实现-->
    <bean id="annotationPointCut" class="com.zhou.diy.AnnotationPointCut"/>
<!--    开启注解支持   JDK（默认方式）：proxy-target-class="false"   cglib：proxy-target-class="true "-->
    <aop:aspectj-autoproxy proxy-target-class="false"/>
</beans>
```



# [execution表达式](https://www.cnblogs.com/gdwkong/p/8660027.html)

> execution(<修饰符模式>?<返回类型模式><方法名模式>(<参数模式>)<异常模式>?) 

 

除了返回类型模式、方法名模式和参数模式外，其它项都是可选的。

一、通过方法签名定义切点

>  execution(public * *(..))

　　匹配所有目标类的public方法，但不匹配SmartSeller和protected voidshowGoods()方法。第一个*代表返回类型，第二个*代表方法名，而..代表任意入参的方法；

>  execution(* *To(..))

　　匹配目标类所有以To为后缀的方法。它匹配NaiveWaiter和NaughtyWaiter的greetTo()和serveTo()方法。第一个*代表返回类型，而*To代表任意以To为后缀的方法；

二、通过类定义切点

>  execution(*com.baobaotao.Waiter.*(..))

　　匹配Waiter接口的所有方法，它匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()方法。第一个*代表返回任意类型，com.baobaotao.Waiter.*代表Waiter接口中的所有方法；

>  execution(*com.baobaotao.Waiter+.*(..))

　　匹配Waiter接口及其所有实现类的方法，它不但匹配NaiveWaiter和NaughtyWaiter类的greetTo()和serveTo()这两个Waiter接口定义的方法，同时还匹配NaiveWaiter#smile()和NaughtyWaiter#joke()这两个不在Waiter接口中定义的方法。

三、通过类包定义切点

　　在类名模式串中，".*"表示包下的所有类，而"..*"表示包、子孙包下的所有类。

>  execution(* com.baobaotao.*(..))l

　　匹配com.baobaotao包下所有类的所有方法；

>  execution(* com.baobaotao..*(..))l

　　匹配com.baobaotao包、子孙包下所有类的所有方法，如com.baobaotao.dao，com.baobaotao.servier以及com.baobaotao.dao.user包下的所有类的所有方法都匹配。".."出现在类名中时，后面必须跟"*"，表示包、子孙包下的所有类；  

>  execution(* com..*.*Dao.find*(..))

　　匹配包名前缀为com的任何包下类名后缀为Dao的方法，方法名必须以find为前缀。如com.baobaotao.UserDao#findByUserId()、com.baobaotao.dao.ForumDao#findById()的方法都匹配切点。

四、通过方法入参定义切点

　　切点表达式中方法入参部分比较复杂，可以使用"*"和".."通配符，其中"*"表示任意类型的参数，而".."表示任意类型参数且参数个数不限。 

>  execution(* joke(String,int)))

　　匹配joke(String,int)方法，且joke()方法的第一个入参是String，第二个入参是int。它匹配NaughtyWaiter#joke(String,int)方法。如果方法中的入参类型是[Java](http://lib.csdn.net/base/java).lang包下的类，可以直接使用类名，否则必须使用全限定类名，如joke(java.util.List,int)；

>  execution(* joke(String,*)))

　　匹配目标类中的joke()方法，该方法第一个入参为String，第二个入参可以是任意类型，如joke(Strings1,String s2)和joke(String s1,double d2)都匹配，但joke(String s1,doubled2,String s3)则不匹配；

>  execution(* joke(String,..)))

　　匹配目标类中的joke()方法，该方法第 一个入参为String，后面可以有任意个入参且入参类型不限，如joke(Strings1)、joke(String s1,String s2)和joke(String s1,double d2,Strings3)都匹配。

>  execution(* joke(Object+)))

　　匹配目标类中的joke()方法，方法拥有一个入参，且入参是Object类型或该类的子类。它匹配joke(Strings1)和joke(Client c)。如果我们定义的切点是execution(*joke(Object))，则只匹配joke(Object object)而不匹配joke(Stringcc)或joke(Client c)。

五、args()和@args()

　　args()函数的入参是类名，@args()函数的入参必须是注解类的类名。虽然args()允许在类名后使用+通配符后缀，但该通配符在此处没有意义：添加和不添加效果都一样。

1、args()

　　该函数接受一个类名，表示目标类方法入参对象按类型匹配于指定类时，切点匹配，如下面的例子：

> args(com.baobaotao.Waiter)

　　表示运行时入参是Waiter类型的方法，它和execution(**(com.baobaotao.Waiter))区别在于后者是针对类方法的签名而言的，而前者则针对运行时的入参类型而言。如args(com.baobaotao.Waiter)既匹配于addWaiter(Waiterwaiter)，也匹配于addNaiveWaiter(NaiveWaiter naiveWaiter)，而execution(**(com.baobaotao.Waiter))只匹配addWaiter(Waiterwaiter)方法；实际上，args(com.baobaotao.Waiter)等价于execution(**(com.baobaotao.Waiter+))，当然也等价于args(com.baobaotao.Waiter+)。

2、@args()

　　该函数接受一个注解类的类名，当方法的运行时入参对象标注发指定的注解时，方法匹配切点。

# 整合MyBatis

步骤：

1. 导入相关jar包
   * junit
   * mybatis
   * mysql
   * spring相关
   * aop织入
   * mybatis-spring 【 new】

```xml
<!--        spring 整合mybatis需要的jar包-->
        <dependency>
            <groupId>org.mybatis</groupId>
            <artifactId>mybatis-spring</artifactId>
            <version>2.0.6</version>
        </dependency>
```

2. 编写配置文件
3. 测试

## 回忆MyBatis

1. 编写实体类

```java
@Data
public class User {
    private String username;
    private String password;
    private String customerNo;
}

```



1. 编写核心配置文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!--核心配置文件-->
<configuration>
    <!--    引入外部文件-->
    <properties resource="db.properties">
        <!--        可以将用户名和密码卸载标签中-->
    </properties>
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
    <typeAliases>
        <package name="com.zhou.pojo"/>
    </typeAliases>
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${driver}"/>
                <property name="url" value="${url}"/>
                <property name="username" value="${username}"/>
                <property name="password" value="${password}"/>
            </dataSource>
        </environment>
    </environments>
    <!--    每个mapper都需要注册-->
    <mappers>
        <mapper class="com.zhou.mapper.UserMapper"/>
    </mappers>
</configuration>
```

db.properties

```properties
driver = com.mysql.cj.jdbc.Driver
url = jdbc:mysql://localhost:3306/commodity?useSSL=true&useUnicode=true&characterEncoding=utf-8
username = root
password = zyc766623393
```



1. 编写接口

```java
public interface UserMapper {
    List<User> selectUsers();
}

```



1. 编写Mapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.zhou.mapper.UserMapper">

    <select id="selectUsers" resultType="user">
        select * from user
    </select>
</mapper>
```



1. 测试

```java
public class Test {
    @org.junit.Test
    public void test() throws IOException {
        String resource = "mybatis-config.xml";
        InputStream in = Resources.getResourceAsStream(resource);
        SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(in);
        SqlSession sqlSession = sessionFactory.openSession();

        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        List<User> users = mapper.selectUsers();

        for (User user : users) {
            System.out.println(user);
        }
    }
}
```

## MyBatis-Spring

### 整合方式一

1. 在spring-dao.xml中编写数据源配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

<!--
    DataSource:使用Spring的数据源替换MyBatis的配置  c3p0  dbcp  druid
    这里使用Spring提供的JDBC ：org.springframework.jdbc.datasource
-->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/commodity?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8"/>
        <property name="username" value="root"/>
        <property name="password" value="zyc766623393"/>
    </bean>
</beans>
```



1. 在spring-dao.xml中，sqlSessionFactory

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

<!--    sqlSessionFactory-->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource" />
<!--        绑定Mybatis配置文件-->
        <property name="configLocation" value="classpath:mybatis-config.xml"/>
<!--        相当于Mybatis注册mapper-->
        <property name="mapperLocations" value="classpath:com/zhou/mapper/*.xml"/>
    </bean>

</beans>
```



1. 在spring-dao.xml中，sqlSessionTemplate

```xml
<!--    sqlSessionTemplate：就相当于我们使用的sqlSession-->
    <bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
<!--只能通过构造器注入sqlSessionFactory，因为他没有Set方法-->
        <constructor-arg index="0"  ref="sqlSessionFactory"/>
    </bean>
```



1. 需要给接口加实现类【】

```java
public class UserMapperImpl implements UserMapper{

//    在MyBatis中所有的操作都是通过sqlSession执行的，在Spring中所有的操作都是通过sqlSessionTemplate执行
    private SqlSessionTemplate sqlSessionTemplate;

    public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate) {
        this.sqlSessionTemplate = sqlSessionTemplate;
    }


    @Override
    public List<User> selectUsers() {
        UserMapper mapper = sqlSessionTemplate.getMapper(UserMapper.class);
        return mapper.selectUsers();
    }
}

```



1. 将自己的实现类注入到Spring中

```xml
<!--将实现类注入Spring-->
    <bean id="userMapper" class="com.zhou.mapper.UserMapperImpl">
        <property name="sqlSessionTemplate" ref="sqlSession"/>
    </bean>
```



1. 测试使用

```java
//    整合Spring和MyBatis之后
    @org.junit.Test
    public void test2(){
        ApplicationContext context = new ClassPathXmlApplicationContext("spring-dao.xml");
        UserMapper userMapper = context.getBean("userMapper", UserMapper.class);

        for (User user : userMapper.selectUsers()) {
            System.out.println(user);
        }
    }
```

UserMapper接口：

```java
public interface UserMapper {
    List<User> selectUsers();
}
```

UserMapper.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.zhou.mapper.UserMapper">

    <select id="selectUsers" resultType="user">
        select * from user
    </select>
</mapper>
```

mybatis-config.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!--核心配置文件-->
<configuration>
    <!--    引入外部文件-->
    <properties resource="db.properties">
        <!--        可以将用户名和密码卸载标签中-->
    </properties>
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
    <typeAliases>
        <package name="com.zhou.pojo"/>
    </typeAliases>
</configuration>
```

注意：在写xml文件的时候，不能书写多的空格

### 整合方式二

userMapper

```java
public interface UserMapper {
    List<User> selectUsers();
}
```

User

```java
@Data
public class User {
    private String username;
    private String password;
    private String customerNo;
}

```

UserMapperImpl

```java
public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper{

    @Override
    public List<User> selectUsers() {
        SqlSession sqlSession = getSqlSession();
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);

        return mapper.selectUsers();
    }
}

```

mybatis-config.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<!--核心配置文件-->
<configuration>
    <!--    引入外部文件-->
    <properties resource="db.properties">
        <!--        可以将用户名和密码卸载标签中-->
    </properties>
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
    <typeAliases>
        <package name="com.zhou.pojo"/>
    </typeAliases>
</configuration>
```

spring-dao.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        https://www.springframework.org/schema/aop/spring-aop.xsd">

<!--
    DataSource:使用Spring的数据源替换MyBatis的配置  c3p0  dbcp  druid
    这里使用Spring提供的JDBC ：org.springframework.jdbc.datasource
-->
    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost:3306/commodity?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf-8"/>
        <property name="username" value="root"/>
        <property name="password" value="zyc766623393"/>
    </bean>

<!--    sqlSessionFactory-->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource" />
<!--        绑定Mybatis配置文件-->
        <property name="configLocation" value="classpath:mybatis-config.xml"/>
<!--        相当于Mybatis注册mapper-->
        <property name="mapperLocations" value="classpath:com/zhou/mapper/*.xml"/>
    </bean>
<!--    使用第二种方式-->
    <bean id="userMapper2" class="com.zhou.mapper.UserMapperImpl2">
        <property name="sqlSessionFactory" ref="sqlSessionFactory"/>
    </bean>
</beans>

```

Test

```java
 //    整合Spring和MyBatis方式二
    @org.junit.Test
    public void test3(){
        ApplicationContext context = new ClassPathXmlApplicationContext("spring-dao.xml");
        UserMapper userMapper = context.getBean("userMapper2", UserMapper.class);

        for (User user : userMapper.selectUsers()) {
            System.out.println(user);
        }
    }
```

# 声明式事务

## 事务回顾

* 把一组业务当作一个业务，要么都成功，要么都失败
* 事务在项目开发中，十分重要，涉及到数据一致性问题，不能马虎
* 确保完整性和一致性

事务的ACID原则：

* 原子性
* 一致性
* 隔离性
  * 多个业务可能操作同一个资源，防止数据损坏
* 持久性
  * 事务一旦提交，无论系统发生什么问题，结果不会再被影响，被持久化存储到存储器中。

## Spring中的事务管理

* 声明式事务：AOP

在spring-dao.xml中书写：

```xml

<!--    配置声明式事务-->
    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <constructor-arg ref="dataSource" />
    </bean>

<!--    结合AOP实现事务的织入-->
<!--    配置事务通知-->
    <tx:advice id="txAdvice" transaction-manager="transactionManager">
<!--        给哪些方法配置事务-->
<!--        配置事务的传播特性：propagation
            一共有七种：
             REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 Spring默认
             SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。
             MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。
            REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。
            NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
            NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。
            NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。
-->
        <tx:attributes>
            <tx:method name="add" propagation="REQUIRED"/>
            <tx:method name="delete" propagation="REQUIRED"/>
            <tx:method name="update" propagation="REQUIRED"/>
<!--            只读-->
            <tx:method name="select" read-only="true"/>
            <tx:method name="*" propagation="REQUIRED"/>
        </tx:attributes>
    </tx:advice>

<!--    配置事务的切入点-->
    <aop:config>
        <aop:pointcut id="txPointCut" expression="execution(* com.zhou.mapper.*.*(..))"/>
        <aop:advisor advice-ref="txAdvice" pointcut-ref="txPointCut"/>
    </aop:config>
```



* 编程式事务：需要在代码中进行事务的管理

思考：

为什么需要事务？

* 如果不配置事务，可能出现数据提交不一致的情况。
* 如果不在Spring中配置声明式事务，我们就需要在代码中手动配置事务，或者用SQL语言创建事务。
* 事务在项目开发中十分重要，涉及到数据的一致性和完整性问题。