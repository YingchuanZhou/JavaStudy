# 多线程讲解

学无止境,不学习就会被社会淘汰。笔记总结自[狂神说多线程讲解](https://www.bilibili.com/video/BV1V4411p7EF?p=1)

## 基本概念

* 进程
  * 进程就是执行程序的一次执行过程,它是一个动态的概念,式系统资源分配的单位
  * 通常再一个进程中可以包含若干个线程,当然一个进程中至少有一个线程,不然没有存在的意义,线程是CPU调度和执行的单

* 线程
  * 线程就是独立的执行路径
  * 在程序运行时,即使没有自己创建线程,后台也会有多个线程,比如主线程,GC线程
  * main()称之为主线程,为系统的入口,用于执行整个程序
  * 在一个进程中,如果开辟了多个线程,线程的运行是由调度器安排调度的,调度器是与操作系统紧密相关的,先后顺序是不能人为干预的
  * 对同一份资源操作时mm会存在资源抢夺的问题,需要加入并发控制
  * 线程会带来额外的开销,如CPU调度时间,并发控制开销
  * 每个线程在自己的工作内存交互,内存控制不当会造成数据不一致

* 多线程

# 线程创建

## 三种创建方式

1. 继承自Thread类,重写run方法,创建实例调用start方法

```java
package createthread;

//创建线程得方式一：继承Thead类，重写run方法，调用start开启线程
public class TestThread extends Thread{
    @Override
    public void run() {
//        Run方法线程体
        for (int i = 0; i < 20; i++) {
            System.out.println("我在看代码"+i);
        }
    }

    public static void main(String[] args) {
//        main线程，主线程

//        创建一个线程对象
        TestThread testThread = new TestThread();

//        调用start方法执行线程，但是线程不一定立即执行，由CPU调度安排
        testThread.start();

        for (int i = 0; i < 1000; i++) {
            System.out.println("我在学习多线程"+i);
        }
    }
}

```

2. 实现Runnable接口,实现run方法,创建Thread时作为参数传入,调用start方法

```java
package createthread;

//创建线程的方式二：实现Runnable接口，重写run方法，线程需要使用线程对象开启，并且丢入Runnable接口的实现类对象
public class TestThread2 implements Runnable{

    public void run() {
//        Run方法线程体
        for (int i = 0; i < 20; i++) {
            System.out.println("我在看代码"+i);
        }
    }

    public static void main(String[] args) {
//        创建Runnable接口实现类的对象

        TestThread2 testThread2 = new TestThread2();

//        创建线程对象，通过线程对象来开启线程，通过代理的方式
        Thread thread = new Thread(testThread2);
        thread.start();

//        简写
//        new Thread(testThread2).start();
        for (int i = 0; i < 1000; i++) {
            System.out.println("我在学习多线程"+i);
        }
    }
}
```

抢票案例：

```java
package createthread;

//多个线程同时操作同一个对象
//以买票为例

//发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱
public class TestThead3 implements Runnable{

//    票数
    private int ticketNums = 10;
    
    public void run() {
        while (true){
            if (ticketNums <= 0){
                break;
            }

//            模拟延时
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName()+"--->拿到了第"+ticketNums--+"张票");
        }
    }

    public static void main(String[] args) {
        TestThead3 tick = new TestThead3();

        new Thread(tick,"ZZZ").start();
        new Thread(tick,"WWW").start();
        new Thread(tick,"HHH").start();
    }
}

```

3. 实现Callable接口

- 可以定义返回值
- 可以抛出异常

```java
package createthread;

import java.util.concurrent.*;

//床技安线程的方式三：实现Callable接口
public class TestThread4 implements Callable<Boolean> {

        public Boolean call() throws Exception {
            System.out.println("创建成功");
            return true;
        }

        public static void main(String[] args) throws ExecutionException, InterruptedException {
            TestThread4 callable = new TestThread4();

            //创建执行服务
            ExecutorService service = Executors.newFixedThreadPool(1);
            //提交执行
            Future<Boolean> result = service.submit(callable);
//          获取结果
            boolean isTrue = result.get();
//           关闭服务
            service.shutdownNow();

        }
}
```

# Lambda表达式

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020111819495874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9feWFuXw==,size_16,color_FFFFFF,t_70#pic_center)

## 推导lambda

函数式接口：一个接口中只有一个函数

```java
package test;

/*
推到lambda
 */

import static java.lang.System.*;

public class testlamda1 {

    //3. 静态内部类
    static class Like2 extends Like implements Ilike {
        @Override
        public void lambda() {
            out.println("i like javaee");
        }

        public static void main(String[] args) {
            Ilike like = new Like();
            like.lambda();
            like = new Like2();
            like.lambda();


            //4.局部内部类
            class Like3 extends Like implements Ilike {
                @Override
                public void lambda() {
                    out.println("i like spring ");
                }
            }
            like = new Like3();
            like.lambda();

//            5。匿名内部类（没有类的名称，必须借助接口或父类）
            like = new Ilike(){
                @Override
                public void lambda() {
                    out.println("i like maven");
                }
            };
            like.lambda();

//            6. lambda简化
            like = ()->{
                out.println("i like javase ");
            };
            like.lambda();


        }
    }


    //1. 定义一个函数式接口
    interface Ilike {
        void lambda();
    }

    // 2. 实现类
    static class Like implements Ilike {
        @Override
        public void lambda() {
            out.println("i like java");
        }
    }
}
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020111820235125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9feWFuXw==,size_16,color_FFFFFF,t_70#pic_center)

例一：

```java
package test;

public class testlambda2 {
    public static void main(String[] args) {
        ILove love = (int a)->{
            System.out.println("i love number"+a);
        };
        love.love(14);

    }
}


interface ILove{
    void love(int a);
}
```

简化：

```java
package test;

public class testlambda2 {
    public static void main(String[] args) {
//        简化1
        ILove love = null;
        love = a -> {
            System.out.println("i love "+a);
        };
        love.love(5);
//        简化2
        love = a -> System.out.println("i love aa"+a);
        love.love(520);
    }
}

interface ILove{
    void love(int a);
}
```

注意：

- 必须是函数是接口（接口里只有一个方法）
- lambda表达式只能有一行代码的情况下才能简化为一行，如果有多行，那么就用代码块包裹
- 前提是接口为函数式接口
- 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号。

# 线程状态

- 创建状态
- 就绪状态
- 阻塞状态
- 运行状态
- 死亡状态

![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-i5xJhuPZ-1592308713404)(C:\Users\车泽平\AppData\Roaming\Typora\typora-user-images\1592285267192.png)]](https://img-blog.csdnimg.cn/20200616195901820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUwMjUwOQ==,size_16,color_FFFFFF,t_70#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/2020061619592330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUwMjUwOQ==,size_16,color_FFFFFF,t_70#pic_center)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200616195944721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUwMjUwOQ==,size_16,color_FFFFFF,t_70#pic_center)

## 停止线程

![[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-w0gzJZok-1592308713424)(C:\Users\车泽平\AppData\Roaming\Typora\typora-user-images\1592285523432.png)]](https://img-blog.csdnimg.cn/20200616195959263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDUwMjUwOQ==,size_16,color_FFFFFF,t_70#pic_center)

```java
public class TestStop implements Runnable {
    private boolean flag=true;
    @Override
    public void run() {
        int i=0;
        while (flag){
            System.out.println("run.....Thread"+(i++));
        }
    }
    public void stop(){
        this.flag=false;
    }
​
    public static void main(String[] args) {
        TestStop testStop = new TestStop();
        new Thread(testStop).start();
        for (int i = 0; i <1000 ; i++) {
            System.out.println("main"+i);
            if (i==900){
                testStop.stop();
                System.out.println("线程停止了！");
            }
        }
    }
}
```



## 线程休眠 sleep()

- sleep(毫秒数)指定当前线程停止的实践
- sleep()存在异常InteruptedException
- sleep()实践到达后线程进入就绪状态
- sleep()可以模拟网络延时,倒计时等
- **每一个对象都有一个锁,sleep不会释放锁**

```java
public class TestSleep1 {
    public static void main(String[] args) {
    tenDown();
    //打印当前系统时间
        Date startTime=new Date(System.currentTimeMillis());//获取当前系统时间
        while (true){
            try {
                Thread.sleep(1000);
                System.out.println(new SimpleDateFormat("HH:mm:ss").format(startTime));
                startTime=new Date(System.currentTimeMillis());//更新时间
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
    //模拟倒计时
    public static void tenDown(){
        int num=10;
        while (true){
            try {
                Thread.sleep(1000);
                if (num<=0){
                    break;
                }else{
                    System.out.println("倒计时！！！"+num--+"秒");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```



## 线程礼让 yield()

- **礼让线程,让当前正在执行的线程暂停,但不阻塞**
- 将线程从运行状态转为就绪状态
- **让CPU重新调度,礼让不一定成功,看CPU心情**

```java
public class TestYield implements Runnable {
    public static void main(String[] args) {
        TestYield yield=new TestYield();
        new Thread(yield,"a").start();
        new Thread(yield,"b").start();
    }
    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"线程开始执行");
        Thread.yield();//礼让
        System.out.println(Thread.currentThread().getName()+"线程停止执行");
    }
}
```



## 线程强制执行 join()

- Join合并线程,待此线程执行完成后,在执行其他线程,其他线程阻塞
- 可以想象成插队

```java
public class TestJoin implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i <100 ; i++) {
            System.out.println("VIP线程来插队了！！！"+i);
        }
    }


        public static void main(String[] args) throws InterruptedException {
           Thread thread= new Thread(new TestJoin());

            for (int i = 0; i <400 ; i++) {
                System.out.println("主线程在排队！！！"+i);
                if (i==100){
                    thread.start();
                    thread.join();

            }
        }
    }
}
```

## 线程状态观测

Thread.State

线程状态，线程可以处于一下状态之一：

- new 尚未启动的线程处于此状态
- Runnable 在java虚拟机中执行的线程处于此状态
- Blocked 被阻塞等待监视器锁定的线程处于此状态。
- Waiting 正在等待另一个线程执行特定动作的线程处于此状态。
- Timed Waiting 正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
- Terminated 已退出的线程处于此状态。

一个线程可以给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态

```java
public class TestState {
    public static void main(String[] args) throws InterruptedException {
        Thread thread=new Thread(()->{
            for (int i = 0; i <5 ; i++) {
                try {
                    Thread.sleep(1000);

                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.println("////////////////");
        });
        Thread.State state = thread.getState();
        System.out.println(state);//new
        thread.start();//启动线程
        state=thread.getState();//runnable
        System.out.println(state);
        while (state!= Thread.State.TERMINATED){//只要线程不终止就输入线程状态
            Thread.sleep(100);
            state=thread.getState();
            System.out.println(state);
        }
    }
}
```

## 线程优先级

java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。

线程的优先级用数字表示，范围从1~10。

使用以下方式改变或获取优先级

getPriority().setPriority(int xxx)

```java
public class TestPriority {
    public static void main(String[] args) {
        MyPriority myPriority = new MyPriority();
        Thread t1 = new Thread(myPriority);
        Thread t2 = new Thread(myPriority);
        Thread t3 = new Thread(myPriority);
        Thread t4 = new Thread(myPriority);
        Thread t5 = new Thread(myPriority);
        Thread t6 = new Thread(myPriority);
        //先设置线程优先级
        t1.setPriority(1);
        t1.start();
        t2.setPriority(3);
        t2.start();
        t3.setPriority(6);
        t3.start();
        t4.setPriority(Thread.MAX_PRIORITY);//  优先级=10
        t4.start();
        t5.setPriority(Thread.MIN_PRIORITY);// 优先级=1
        t6.setPriority(9);
        t6.start();

        System.out.println("main");
    }
}
class MyPriority implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName()+"---线程被执行了！---"+Thread.currentThread().getPriority());
    }
}
```

注意：先设置优先级，再start线程！！！

## 守护（daemon）线程

- 线程分为用户线程和守护线程
- **虚拟机必须确保用户线程执行完毕**
- **虚拟机不用等待守护线程执行完毕**,用户线程执行完毕之后，守护线程会自动停止
- 如，后台记录操作日志，监控内存，垃圾回收等待。。。

```java
public class TestDaemon {
    public static void main(String[] args) {
        God god = new God();
        You you=new You();
        Thread thread = new Thread(god);
        thread.setDaemon(true);//默认为flase 为用户线程，  true为守护线程
        thread.start();
        new Thread(you).start();
    }
}
class God implements Runnable{

    @Override
    public void run() {
        while (true){
            System.out.println("上帝守护着你-------");
        }
    }
}
class You implements Runnable{

    @Override
    public void run() {
        for (int i = 0; i <36500 ; i++) {
            System.out.println("开心着活着每一天------");
        }
        System.out.println("----goodbye!Beautiful World!!!------");

    }
}
```

# 线程同步机制

线程同步

- 由于同一进城的多个线程共享同一块存储空间，在带来方便的同事，也带来了访问冲突问题，为了保证数据在方法中被访问时的正确性，在访问时加入锁机制synchronized，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：

- 一个线程持有锁会导致其它所有需要此锁的线程挂起；

- 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题；

- 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置，引起性能问题。

  

### 线程锁

**不安全案例**

1. 买票不安全

```java
//不安全的买票
public class UnsafeButTicket {
    public static void main(String[] args) {
        BuyTicket bt=new BuyTicket();
        new Thread(bt,"我").start();
        new Thread(bt,"你").start();
        new Thread(bt,"黄牛党").start();
    }
}

class BuyTicket implements Runnable{
    //票
    private int ticketNums=10;
     boolean flag=true;//外部停止方式
    @Override
    public void run() {
        //买票
        while (flag){
            buy();
        }
    }
    public synchronized void buy(){//锁了方法，相当于this 把类给锁住

        //判断是否有票
        if(ticketNums<=0){
            System.out.println("票没了");
            flag=false;
            return ;
        }
        //模拟延时
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(Thread.currentThread().getName()+ticketNums--);
    }
}
```

2. 取钱不安全

```java
//不安全取钱
    //两个人去银行取钱，账户
public class UnsafeBank {
    public static void main(String[] args) {
        //账户
        Account account=new Account(100,"结婚基金");
        Drawing you=new Drawing(account,50,"你");
        Drawing girlFriend=new Drawing(account,100,"女朋友");
        you.start();
        girlFriend.start();
    }
}
//账户
class Account{
    int money;//余额
    String name;//卡名

    public Account(int money, String name) {
        this.money = money;
        this.name = name;
    }
}
//银行：模拟取款
class Drawing extends Thread{
    Account account;//账户
    //取了多少钱；
    int drawingMoney;
    //现在手里又多少钱
    int nowMoney;
    public Drawing(Account account,int drawingMoney,String name){
        super(name);
        this.account=account;
        this.drawingMoney=drawingMoney;

    }
    //取钱
	//synchronized 同步锁默认锁的是this
    @Override
    public void run() {
        synchronized (account) {//锁的对象是变化的量，锁需要增删改的对象
            //判断有没有钱
            if (account.money - drawingMoney <= 0) {
                System.out.println(Thread.currentThread().getName() + "钱不够");
                return;
            }
            //卡内余额
            account.money -= drawingMoney;
            //手里的钱
            nowMoney += drawingMoney;
            System.out.println(account.name + "余额为:" + account.money);
            System.out.println(this.getName() + "手里的钱:" + nowMoney);
        }
    }
}
```

3. 集合不安全

```java
public class UnsafeList {
    public static void main(String[] args) {
        ArrayList<String> list=new ArrayList<String>();
        for (int i = 0; i <1000 ; i++) {
            new Thread(()->{
                synchronized (list){
                    list.add(Thread.currentThread().getName());
                }
            }).start();
            try {
                Thread.sleep(30);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(list.size());
    }
}
```

### 同步块

Synchronized(Obj){}

**Obj**称之为同步监视器

- Obj可以是任何对象，但是推荐使用共享资源作为同步监视器
- 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this,就是这个对象本身，或者是class【反射中讲解】

同步监视器的执行过程：

1. 第一个线程访问，锁定同步监视器，执行其中代码
2. 第二个线程访问，发现同步监视器被锁定，无法访问
3. 第一个线程访问完毕，皆出同步监视器
4. 第二个线程访问，发现同步监视器没有锁

### 死锁

- 多个线程各自占有一些共享资源,并且互相等待其他线程占有的资源释放才能运行,而导致两个或者多个线程都在等待对方释放资源,都停止执行的情形,**某一个同步块同时拥有"两个以上的对象锁"时,就可能发生死锁现象**

### 死锁避免方法

产生死锁的四个必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用。

2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不妨。

3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。

4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

# Lock锁

- JDK5.0开始，java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当

- java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象

- ReentrantLock类实现了Lock，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。

  ### synchronized与Lock的对比

  - Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了作用域自动释放
  - Lock只有代码块加锁，synchronized有代码块锁和方法锁
  - 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）
  - 优先使用顺序：
  - Lock > 同步代码块（已经进入了方法体，分配了相应资源）> 同步方法（在方法体之外）

```java
public class TestLock {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
        new Thread(ticket).start();
        new Thread(ticket).start();
        new Thread(ticket).start();
    }

}
class Ticket extends Thread{
    private int ticketNums=10;
    //定义lock锁
    private final ReentrantLock lock=new ReentrantLock();

    @Override
    public void run() {
        while (true){
            try {
                lock.lock();//加锁
                if (ticketNums > 0) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(ticketNums--);
                } else {
                    break;
                }
            }finally {
                lock.unlock();//减锁
            }
        }
    }
}
```

### 解决线程之间通信的方式1：管程法

并发写作模型“生产者/消费者模式”–>管程法

- 生产者：负责生产数据的模块（可能是方法，对象，线程，进程）；
- 消费者：负责处理数据的模块（可能是方法，对象，线程，进程）
- 缓冲区：消费者不能直接使用生产者的数据，他们之间有个缓冲区

**生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20201118204851327.png#pic_center)

```java
/**
 * @author: sjmp1573
 * @date: 2020/11/18 20:52
 * @description:
 */

// 生产者,消费者,产品,缓冲区
public class TestPC {
    public static void main(String[] args) {
        SynContainer container = new SynContainer();

        new Productor(container).start();
        new Consumer(container).start();
    }

}

// 生产者
class Productor extends Thread{
    SynContainer container;
    public Productor(SynContainer container){
        this.container = container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("生产了"+i+"只鸡");
            container.push(new Chicken(i));
        }
    }
}


class SynContainer{
//    需要一个容器的大小
    Chicken[] chickens = new Chicken[10];
//    容器计数器
    int count = 0;


//    生产者放入产品
    public synchronized void push(Chicken chicken){
//        如果容器满了,就需要等待消费者消费
        if (count == chickens.length){
//            通知消费者消费,生产等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        chickens[count] = chicken;
        count++;
        this.notifyAll();
    }


//    消费者消费产品
    public synchronized Chicken pop(){
//        判断能否消费
        if(count==0){
//            等待生产者生产,消费者等待
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
//        如果可以消费
        count--;
        Chicken chicken = chickens[count];
//        可以通知消费了
        this.notifyAll();

        return chicken;
    }
}



class Consumer extends Thread{
    SynContainer container;
    public Consumer(SynContainer container){
        this.container = container;
    }

    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println("消费了-->"+container.pop().id+"只鸡");
        }
    }
}



// 产品
class Chicken{
    int id;  //产品编号
    public Chicken(int id){
        this.id = id;
    }
}
```

### 解决线程之间通信的方式1：信号灯法

```java
/**
 * @author: sjmp1573
 * @date: 2020/11/18 21:34
 * @description:
 */

public class TestPC2 {
    public static void main(String[] args) {
        TV tv = new TV();
        new Player(tv).start();
        new Wathcher(tv).start();
    }
}

//生产者--演员
class Player extends Thread{
    TV tv;
    public Player(TV tv){
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            if(i%2==0){
                this.tv.play("快乐大本营");
            }else{
                this.tv.play("天天向上");
            }
        }
    }
}

//观众
class Wathcher extends Thread{
    TV tv;
    public Wathcher(TV tv){
        this.tv = tv;
    }

    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            tv.watch();
        }
    }
}

//产品--节目
class TV{
//    演员表演,观众等待  T
//    观众观看,演员等待  F
    String voice;  // 表演节目
    boolean flag = true;

//    表演
    public synchronized void play(String voice){
        if(!flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("演员表演了: "+voice);
//        通知观众观看
        this.notifyAll();// 通知唤醒
        this.voice = voice;
        this.flag = !flag;
    }

//    观看
    public synchronized void watch(){
        if (flag){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("观看了: "+voice);
//        通知演员表演
        this.notifyAll();
        this.flag = !this.flag;
    }
}
```

## 使用线程池

背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。
思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。
可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。

**优点：**
提高响应速度（减少了创建新线程的时间）
降低资源消耗（重复利用线程池中线程，不需要每次都创建）
便于线程管理…

- corePoolSize:核心池的大小
- maximumPoolSize:最大线程数
- keepAliveTime：线程没有任务时最多保持多长时间会终止

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @author: sjmp1573
 * @date: 2020/11/18 21:53
 * @description:
 */

public class TestPool {
    public static void main(String[] args) {
//        1.创建服务,创建线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
//        newFixedThreadPool 参数为线程池大小
//        执行
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());
        service.execute(new MyThread());

//        2.关闭连接
        service.shutdown();

    }
}
class MyThread implements Runnable{

    @Override
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }
}
```

## 补充内容

```java
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * @ClassName ThreadFutureTest
 * @Description TODO
 * @Author sjmp1573
 * @Date DATE{TIME}
 */
public class ThreadFutureTest {
    public static class CallerTask implements Callable<String>{
        @Override
        public String call() throws Exception {
            return "Thread-Callable- hello";
        }
    }

    public static void main(String[] args) {
        // 创建异步任务
        FutureTask<String> futureTask = new FutureTask<>(new CallerTask());
        new Thread(futureTask).start();
        try {
            String result = futureTask.get();
            System.out.println(result);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

​		如上代码中的 CallerTask 类实现了 Callable 接口的 call() 方法。在 main 函数内首先创建了一个 FutrueTask 对象（构造函数为 CallerTask 的实例），然后使用创建的 FutrueTask 对象作为任务创建了一个线程并且启动它，最后通过futureTask.get() 等待任务执行完毕并返回结果。

​		小结：使用继承方式的好处是方便传参，你可以在子类里面添加成员变量，通过 set 方法设置参数或者通过构造函数进行传递，而如果使用 Runnable 方式，则只能使用主线程里面被声明为 final 的变量。不好的地方是 Java 不支持多继承，如果继承了 Thread 类，那么子类不能再继承其他类，而 Runable 则没有这个限制。前两种方式都没办法拿到任务的返回结果，但是 Futuretask 方式可以。